## LangGraph è®°å¿†ç³»ç»Ÿå®æˆ˜ï¼šåé¦ˆå¾ªç¯ + åŠ¨æ€ Prompt è®© AI æŒç»­å­¦ä¹ 

[*è…¾è®¯äº‘*](/?from=20060&from_column=20060)
[*å¼€å‘è€…ç¤¾åŒº*](/developer)

[æ–‡æ¡£](/document/product?from=20702&from_column=20702)[å»ºè®®åé¦ˆ](/voc/?from=20703&from_column=20703)[æ§åˆ¶å°](https://console.cloud.tencent.com?from=20063&from_column=20063)

[é¦–é¡µ](/developer)

æ–‡ç« /ç­”æ¡ˆ/æŠ€æœ¯å¤§ç‰›

deephub

[ç¤¾åŒºé¦–é¡µ](/developer) >[ä¸“æ ](/developer/column) >LangGraph è®°å¿†ç³»ç»Ÿå®æˆ˜ï¼šåé¦ˆå¾ªç¯ + åŠ¨æ€ Prompt è®© AI æŒç»­å­¦ä¹ 

# LangGraph è®°å¿†ç³»ç»Ÿå®æˆ˜ï¼šåé¦ˆå¾ªç¯ + åŠ¨æ€ Prompt è®© AI æŒç»­å­¦ä¹ 

deephub

å‘å¸ƒäº 2025-11-15 11:44:45

å‘å¸ƒäº 2025-11-15 11:44:45

8610

æ–‡ç« è¢«æ”¶å½•äºä¸“æ ï¼š[DeepHub IMBA](/developer/column/86944)DeepHub IMBA

**ç‚¹å‡»ä¸Šæ–¹â€œDeephub Imbaâ€,å…³æ³¨å…¬ä¼—å·,å¥½æ–‡ç« ä¸é”™è¿‡ !**

ä»£ç†ç³»ç»Ÿæˆ–è€… RAG æ–¹æ¡ˆï¼ŒåŸºæœ¬éƒ½éœ€è¦ä¸€ä¸ªåŒå±‚è®°å¿†æ¶æ„ï¼Œè¿™æ · LLM æ—¢èƒ½ä¿æŒå¯¹å½“å‰ä¸Šä¸‹æ–‡çš„ä¸“æ³¨ï¼Œåˆèƒ½è®°ä½è¿‡å¾€äº¤äº’çš„å†…å®¹ã€‚

çŸ­æœŸè®°å¿†è´Ÿè´£å•ä¸ªä¼šè¯å†…çš„å³æ—¶ä¿¡æ¯ç®¡ç†ï¼Œé•¿æœŸè®°å¿†åˆ™è·¨ä¼šè¯å­˜å‚¨çŸ¥è¯†ï¼Œè®©ç³»ç»Ÿèƒ½å¤ŸæŒç»­å­¦ä¹ å’Œè¿›åŒ–ã€‚ä¸¤è€…é…åˆï¼Œä»£ç†æ‰èƒ½è¡¨ç°å‡ºè¿è´¯æ€§ã€ä¸Šä¸‹æ–‡æ„ŸçŸ¥èƒ½åŠ›ï¼Œçœ‹èµ·æ¥æ›´åŠ æ™ºèƒ½ã€‚è¿™äº›è®°å¿†ç»„ä»¶åœ¨ç°ä»£ AI æ¶æ„ä¸­çš„ä½ç½®å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

#### çº¿ç¨‹çº§è®°å¿†ï¼ˆçŸ­æœŸï¼‰

å¯ä»¥æŠŠå®ƒç†è§£ä¸ºä»£ç†çš„"å·¥ä½œè®°å¿†"ã€‚å®ƒå¸®åŠ©ä»£ç†ç†è§£ä¸Šä¸‹æ–‡ï¼Œè‡ªç„¶åœ°å»¶ç»­è®¨è®ºï¼Œä¸ä¼šä¸¢å¤±ä¹‹å‰çš„æ­¥éª¤ã€‚LangGraph é€šè¿‡æ£€æŸ¥ç‚¹æœºåˆ¶è‡ªåŠ¨ç®¡ç†è¿™éƒ¨åˆ†è®°å¿†ã€‚å¯¹è¯ç»“æŸåï¼ŒçŸ­æœŸè®°å¿†ä¼šè¢«æ¸…ç©ºï¼Œä¸‹æ¬¡ä¼šè¯åˆ™ä¼šé‡æ–°å¼€å§‹ä¸€ä¸ªæ–°çš„è®°å¿†ã€‚

#### è·¨çº¿ç¨‹è®°å¿†ï¼ˆé•¿æœŸï¼‰

LangGraph å°†è¿™äº›æ•°æ®ä»¥ JSON æ–‡æ¡£å½¢å¼ä¿å­˜åœ¨è®°å¿†å­˜å‚¨ä¸­ï¼Œé€šè¿‡å‘½åç©ºé—´ï¼ˆç±»ä¼¼æ–‡ä»¶å¤¹ï¼‰å’Œé”®ï¼ˆç±»ä¼¼æ–‡ä»¶åï¼‰æ•´é½ç»„ç»‡ã€‚å› ä¸ºè¿™ç§è®°å¿†åœ¨å¯¹è¯åä¸ä¼šæ¶ˆå¤±ï¼Œæ‰€ä»¥ä»£ç†èƒ½å¤Ÿéšæ—¶é—´ç§¯ç´¯çŸ¥è¯†ï¼Œæä¾›æ›´ä¸€è‡´ã€æ›´ä¸ªæ€§åŒ–çš„å“åº”ã€‚

> æœ¬æ–‡ä¼šæ¢è®¨ç”Ÿäº§çº§ AI ç³»ç»Ÿå¦‚ä½•ä½¿ç”¨ LangGraph ç®¡ç†é•¿æœŸè®°å¿†æµã€‚LangGraph æ˜¯ä¸€ä¸ªæ„å»ºå¯æ‰©å±•ã€ä¸Šä¸‹æ–‡æ„ŸçŸ¥ AI å·¥ä½œæµçš„ä¸»æµæ¡†æ¶ã€‚

### LangGraph æ•°æ®æŒä¹…å±‚

å¤„ç†ä»£ç†è®°å¿†æ—¶ï¼ŒLangGraph æ˜¯æœ€å¸¸ç”¨çš„ç»„ä»¶ã€‚å…¶ä¸­ Store åŠŸèƒ½å°¤ä¸ºå…³é”®ï¼Œå®ƒæ ¹æ®é¡¹ç›®çš„è¿è¡Œä½ç½®ç®¡ç†è®°å¿†çš„ä¿å­˜ã€æ£€ç´¢å’Œæ›´æ–°æ–¹å¼ã€‚

LangGraph æä¾›äº†å‡ ç§å­˜å‚¨å®ç°ï¼Œåœ¨ç®€å•æ€§ã€æŒä¹…æ€§å’Œå¯æ‰©å±•æ€§ä¹‹é—´å–å¾—å¹³è¡¡ã€‚æ¯ç§é€‰é¡¹é€‚åˆå¼€å‘æˆ–éƒ¨ç½²çš„ç‰¹å®šé˜¶æ®µã€‚

#### InMemory Storeï¼ˆç”¨äº notebook å’Œå¿«é€Ÿæµ‹è¯•ï¼‰

ä½¿ç”¨ `from langgraph.store.memory import InMemoryStore` å¯¼å…¥ï¼Œåˆ›å»ºä¸€ä¸ªå®Œå…¨åœ¨å†…å­˜ä¸­è¿è¡Œçš„å­˜å‚¨ï¼Œä½¿ç”¨æ ‡å‡† Python å­—å…¸ã€‚

ä¸å†™å…¥ç£ç›˜ï¼Œè¿›ç¨‹ç»“æŸåæ‰€æœ‰ä¿¡æ¯éƒ½ä¼šä¸¢å¤±ã€‚ä½†é€Ÿåº¦å¿«ï¼Œæ˜“ç”¨ï¼Œéå¸¸é€‚åˆæµ‹è¯•å·¥ä½œæµæˆ–å°è¯•æ–°çš„å›¾é…ç½®ã€‚å¦‚æœéœ€è¦ï¼Œä¹Ÿå¯ä»¥æ·»åŠ è¯­ä¹‰æœç´¢èƒ½åŠ›ã€‚

#### æœ¬åœ°å¼€å‘å­˜å‚¨ï¼ˆlanggraph devï¼‰

è¿™ä¸ªé€‰é¡¹çš„è¡Œä¸ºä¸ä¸Šé¢çš„å†…å­˜ç‰ˆæœ¬ç±»ä¼¼ï¼Œä½†æ˜¯å¯ä»¥åœ¨ä¼šè¯ä¹‹é—´æä¾›äº†åŸºæœ¬æŒä¹…æ€§ã€‚

ç”¨ `langgraph dev` å‘½ä»¤è¿è¡Œåº”ç”¨æ—¶ï¼ŒLangGraph ä¼šè‡ªåŠ¨ä½¿ç”¨ Python çš„ pickle æ ¼å¼å°†å­˜å‚¨ä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶åœ¨é‡å¯å¼€å‘ç¯å¢ƒåæ¢å¤æ•°æ®ã€‚

è¿™ä¸ªæ–¹å¼è½»é‡ä¸”æ–¹ä¾¿ï¼Œä¸éœ€è¦å¤–éƒ¨æ•°æ®åº“ã€‚åŒæ ·æ”¯æŒè¯­ä¹‰æœç´¢åŠŸèƒ½ï¼Œæ‰€ä»¥å®ƒéå¸¸é€‚åˆå¼€å‘é˜¶æ®µï¼Œä½†ä¸é€‚åˆç”Ÿäº§ç¯å¢ƒã€‚

#### ç”Ÿäº§å­˜å‚¨ï¼ˆLangGraph Platform æˆ–è‡ªæ‰˜ç®¡ï¼‰

å¤§è§„æ¨¡æˆ–ç”Ÿäº§éƒ¨ç½²ï¼ŒLangGraph ä½¿ç”¨ä¸ pgvector é›†æˆçš„ PostgreSQL æ•°æ®åº“å®ç°é«˜æ•ˆçš„å‘é‡å­˜å‚¨å’Œè¯­ä¹‰æ£€ç´¢ã€‚

è¿™æ ·å¯ä»¥æä¾›å®Œæ•´çš„æ•°æ®æŒä¹…æ€§ã€å†…ç½®å¯é æ€§ï¼Œå¹¶ä¸”èƒ½å¤Ÿå¤„ç†æ›´å¤§çš„å·¥ä½œè´Ÿè½½æˆ–å¤šç”¨æˆ·ç³»ç»Ÿã€‚è¯­ä¹‰æœç´¢ä¾é pgvector ï¼Œé»˜è®¤ä½¿ç”¨ä½™å¼¦ç›¸ä¼¼åº¦ä½œä¸ºç›¸ä¼¼æ€§åº¦é‡ï¼Œä¹Ÿå¯ä»¥æ ¹æ®éœ€æ±‚è‡ªå®šä¹‰ã€‚

è¿™ç§é…ç½®ç¡®ä¿è®°å¿†æ•°æ®å®‰å…¨å­˜å‚¨ï¼Œè·¨ä¼šè¯ä¿æŒå¯ç”¨ï¼Œå³ä½¿åœ¨é«˜æµé‡æˆ–åˆ†å¸ƒå¼å·¥ä½œè´Ÿè½½ä¸‹ä¹Ÿèƒ½ç¨³å®šè¿è¡Œã€‚

> åŸºç¡€çŸ¥è¯†ä»‹ç»å®Œæ¯•ï¼Œæ¥ä¸‹æ¥å¼€å§‹é€æ­¥ç¼–å†™å®Œæ•´çš„å·¥ä½œæ¶æ„ä»£ç ã€‚

### InMemory åŠŸèƒ½å®è·µ

æœ¬æ–‡è¦å®ç°çš„æ˜¯ InMemory åŠŸèƒ½ï¼Œè¿™æ˜¯åŸºäº AI ç³»ç»Ÿä¸­æœ€å¸¸ç”¨çš„å†…å­˜ç®¡ç†æ–¹å¼ã€‚

> å®ƒæŒ‰é¡ºåºæ‰§è¡Œï¼Œåœ¨é€æ­¥æ„å»ºæˆ–æµ‹è¯•æŠ€æœ¯æµç¨‹æ—¶éå¸¸å®ç”¨ã€‚

InMemory åŠŸèƒ½å…è®¸åœ¨è¿è¡Œä»£ç æ—¶ä¸´æ—¶å­˜å‚¨æ•°æ®ï¼Œé€šè¿‡äº†è§£å®ƒå¯ä»¥æœ‰åŠ©äºæˆ‘ä»¬ç†è§£ LangGraph ä¸­å†…å­˜å¤„ç†çš„å·¥ä½œåŸç†ã€‚

ä» LangGraph å¯¼å…¥ `InMemoryStore` å¼€å§‹ã€‚è¿™ä¸ªç±»è®©æˆ‘ä»¬ç›´æ¥åœ¨å†…å­˜ä¸­å­˜å‚¨è®°å¿†ï¼Œä¸éœ€è¦å¤–éƒ¨æ•°æ®åº“æˆ–æ–‡ä»¶ç³»ç»Ÿã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Import the InMemoryStore class for storing memories in memory (no persistence) from langgraph.store.memory import InMemoryStore # Initialize an in-memory store instance for use in this notebook in_memory_store = InMemoryStore()
```

è¿™é‡Œåˆ›å»ºäº† InMemoryStore çš„å®ä¾‹ï¼Œç”¨äºä¿å­˜ä¸´æ—¶æ•°æ®ã€‚å› ä¸ºåªåœ¨å†…å­˜ä¸­è¿è¡Œï¼Œè¿›ç¨‹åœæ­¢åæ‰€æœ‰å­˜å‚¨çš„æ•°æ®éƒ½ä¼šè¢«æ¸…é™¤ã€‚

> LangGraph ä¸­çš„æ¯ä¸ªè®°å¿†éƒ½ä¿å­˜åœ¨å‘½åç©ºé—´ï¼ˆnamespaceï¼‰ä¸­ã€‚

å‘½åç©ºé—´åƒæ ‡ç­¾æˆ–æ–‡ä»¶å¤¹ï¼Œå¸®åŠ©ç»„ç»‡è®°å¿†ã€‚å®ƒè¢«å®šä¹‰ä¸ºå…ƒç»„ï¼Œå¯ä»¥æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªéƒ¨åˆ†ã€‚ä¸‹é¢è¿™ä¸ªä¾‹å­ä½¿ç”¨åŒ…å«ç”¨æˆ· ID å’Œ "memories" æ ‡ç­¾çš„å…ƒç»„ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define a user ID for memory storage user_id = "1" # Set the namespace for storing and retrieving memories namespace_for_memory = (user_id, "memories")
```

å‘½åç©ºé—´å¯ä»¥ä»£è¡¨ä»»ä½•ä¸œè¥¿ï¼Œä¸ä¸€å®šåŸºäºç”¨æˆ· IDï¼Œæ‰€ä»¥å¯ä»¥æ ¹æ®åº”ç”¨ç»“æ„è‡ªç”±åˆ†ç»„è®°å¿†ã€‚

ä¸‹é¢æˆ‘ä»¬ä¿å­˜ä¸€ä¸ªè®°å¿†åˆ°å­˜å‚¨ä¸­ï¼Œä½¿ç”¨ `put` æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•éœ€è¦ä¸‰æ ·ä¸œè¥¿ï¼šå‘½åç©ºé—´ã€å”¯ä¸€é”®å’Œå®é™…çš„è®°å¿†å€¼ã€‚

è¿™é‡Œé”®æ˜¯ç”¨ `uuid` åº“ç”Ÿæˆçš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œè®°å¿†å€¼æ˜¯å­˜å‚¨ä¿¡æ¯çš„å­—å…¸â€”â€”ä¸€ä¸ªç®€å•çš„åå¥½è®¾ç½®ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 import uuid # Generate a unique ID for the memory memory_id = str(uuid.uuid4()) # Create a memory dictionary memory = {"food_preference": "I like pizza"} # Save the memory in the defined namespace in_memory_store.put(namespace_for_memory, memory_id, memory)
```

è¿™ä¼šå°†è®°å¿†æ¡ç›®æ·»åŠ åˆ°ä¹‹å‰å®šä¹‰çš„å‘½åç©ºé—´ä¸‹çš„å†…å­˜å­˜å‚¨ä¸­ã€‚

å­˜å‚¨è®°å¿†åï¼Œå¯ä»¥ç”¨ `search` æ–¹æ³•å–å›ã€‚è¿™ä¸ªæ–¹æ³•åœ¨å‘½åç©ºé—´å†…æŸ¥æ‰¾å¹¶è¿”å›å±äºå®ƒçš„æ‰€æœ‰è®°å¿†åˆ—è¡¨ã€‚

æ¯ä¸ªè®°å¿†éƒ½æ˜¯ä¸€ä¸ª `Item` å¯¹è±¡ï¼ŒåŒ…å«å‘½åç©ºé—´ã€é”®ã€å€¼å’Œæ—¶é—´æˆ³ç­‰è¯¦ç»†ä¿¡æ¯ã€‚å¯ä»¥è½¬æ¢ä¸ºå­—å…¸ä»¥ä¾¿æ›´æ¸…æ™°åœ°æŸ¥çœ‹æ•°æ®ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Retrieve all stored memories for the given namespace memories = in_memory_store.search(namespace_for_memory) # View the latest memory memories[-1].dict()
```

åœ¨ notebook ä¸­è¿è¡Œè¿™æ®µä»£ç ï¼Œå¾—åˆ°ä»¥ä¸‹è¾“å‡ºï¼š

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 ###### OUTPUT ###### { 'namespace': ['1', 'memories'], 'key': 'c8619cd4-3d3f-4108-857c-5c8c12f39e87', 'value': {'food_preference': 'I like pizza'}, 'created_at': '2025-10-08T15:46:16.531625+00:00', 'updated_at': '2025-10-08T15:46:16.531625+00:00', 'score': None }
```

è¾“å‡ºæ˜¾ç¤ºäº†å­˜å‚¨çš„è®°å¿†è¯¦æƒ…ã€‚æœ€é‡è¦çš„æ˜¯ **value** å­—æ®µï¼ŒåŒ…å«å®é™…ä¿å­˜çš„ä¿¡æ¯ã€‚å…¶ä»–å­—æ®µå¸®åŠ©è¯†åˆ«å’Œç®¡ç†è®°å¿†åˆ›å»ºçš„æ—¶é—´å’Œä½ç½®ã€‚

å­˜å‚¨å°±ç»ªåï¼Œå¯ä»¥å°†å…¶è¿æ¥åˆ°å›¾ä¸­ï¼Œè®©è®°å¿†å’Œæ£€æŸ¥ç‚¹ååŒå·¥ä½œã€‚è¿™é‡Œä½¿ç”¨ä¸¤ä¸ªä¸»è¦ç»„ä»¶ï¼š

* **InMemorySaver** ç®¡ç†çº¿ç¨‹é—´çš„æ£€æŸ¥ç‚¹
* **InMemoryStore** å­˜å‚¨è·¨çº¿ç¨‹çš„è®°å¿†

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # To enable threads (conversations) from langgraph.checkpoint.memory import InMemorySaver checkpointer = InMemorySaver() # To enable across-thread memory from langgraph.store.memory import InMemoryStore in_memory_store = InMemoryStore() # Compile the graph with the checkpointer and store # graph = graph.compile(checkpointer=checkpointer, store=in_memory_store)
```

è¿™ä½¿å›¾èƒ½å¤Ÿè®°ä½çº¿ç¨‹å†…çš„å¯¹è¯ä¸Šä¸‹æ–‡ï¼ˆçŸ­æœŸï¼‰ï¼Œå¹¶ä½¿ç”¨ç›¸åŒçš„å†…å­˜æœºåˆ¶åœ¨çº¿ç¨‹é—´ä¿ç•™é‡è¦ä¿¡æ¯ï¼ˆé•¿æœŸï¼‰ã€‚

> è¿™æ˜¯è½¬å‘ç”Ÿäº§çº§å­˜å‚¨ä¹‹å‰æµ‹è¯•è®°å¿†è¡Œä¸ºçš„ç®€å•æœ‰æ•ˆæ–¹å¼ã€‚

### æ„å»ºä»£ç†æ¶æ„

åœ¨ä½¿ç”¨è®°å¿†ç³»ç»Ÿå·¥ä½œæµä¹‹å‰ï¼Œéœ€è¦æ„å»ºä½¿ç”¨å®ƒçš„æ™ºèƒ½ä»£ç†ã€‚å› ä¸ºæœ¬æ–‡ä¸“æ³¨äºè®°å¿†ç®¡ç†ï¼Œæ‰€ä»¥åªä¼šæ„å»ºä¸€ä¸ªä¸­ç­‰å¤æ‚çš„ç”µå­é‚®ä»¶åŠ©æ‰‹ï¼Œæ¨¡æ‹Ÿåœ¨çœŸå®åœºæ™¯ä¸­æ¢ç´¢è®°å¿†çš„å·¥ä½œæ–¹å¼ã€‚

ä¸‹é¢æˆ‘ä»¬ä»é›¶å¼€å§‹æ„å»ºè¿™ä¸ªç³»ç»Ÿï¼Œå®šä¹‰æ•°æ®ç»“æ„ã€"å¤§è„‘"ï¼ˆæç¤ºè¯ï¼‰å’Œèƒ½åŠ›ï¼ˆå·¥å…·ï¼‰ã€‚æœ€ç»ˆå¾—åˆ°ä¸€ä¸ªä¸ä»…èƒ½å›å¤é‚®ä»¶ï¼Œè¿˜èƒ½ä»åé¦ˆä¸­å­¦ä¹ çš„ä»£ç†ã€‚

#### å®šä¹‰æ¨¡å¼

å¤„ç†æ•°æ®å‰éœ€è¦å®šä¹‰å…¶å½¢çŠ¶ã€‚æ¨¡å¼æ˜¯ä»£ç†ä¿¡æ¯æµçš„è“å›¾ï¼Œç¡®ä¿ä¸€åˆ‡ç»“æ„åŒ–ã€å¯é¢„æµ‹ä¸”ç±»å‹å®‰å…¨ã€‚

é¦–å…ˆç¼–å†™ `RouterSchema`ã€‚éœ€è¦å®ƒæ˜¯ä¸ºäº†è®©åˆå§‹åˆ†ç±»æ­¥éª¤å¯é ã€‚ä¸èƒ½å†’é™©è®© LLM åœ¨æœŸæœ›æ˜ç¡®å†³å®šæ—¶è¿”å›éç»“æ„åŒ–æ–‡æœ¬ã€‚

è¿™ä¸ª Pydantic æ¨¡å‹ä¼šå¼ºåˆ¶ LLM è¿”å›ä¸€ä¸ªå¹²å‡€çš„ JSON å¯¹è±¡ï¼ŒåŒ…å«æ¨ç†è¿‡ç¨‹å’Œä¸€ä¸ªä¸¥æ ¼ä¸º 'ignore'ã€'respond' æˆ– 'notify' ä¹‹ä¸€çš„åˆ†ç±»ç»“æœã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Import the necessary libraries from Pydantic and Python's typing module from pydantic import BaseModel, Field from typing_extensions import TypedDict, Literal # Define a Pydantic model for our router's structured output. class RouterSchema(BaseModel): """Analyze the unread email and route it according to its content.""" # Add a field for the LLM to explain its step-by-step reasoning. reasoning: str = Field(description="åˆ†ç±»èƒŒåçš„é€æ­¥æ¨ç†ã€‚") # Add a field to hold the final classification. # The `Literal` type restricts the output to one of these three specific strings. classification: Literal["ignore", "respond", "notify"] = Field( description="ç”µå­é‚®ä»¶çš„åˆ†ç±»ã€‚" )
```

è¿™æ˜¯åœ¨ä¸ºåˆ†ç±» LLM åˆ›å»ºå¥‘çº¦ã€‚åé¢ä¸ LangChain çš„ `.with_structured_output()` æ–¹æ³•é…å¯¹æ—¶ï¼Œèƒ½ä¿è¯è¾“å‡ºæ˜¯ä¸€ä¸ªå¯é¢„æµ‹çš„ Python å¯¹è±¡ï¼Œè®©å›¾ä¸­çš„é€»è¾‘æ›´åŠ å¥å£®ã€‚

æ¥ä¸‹æ¥éœ€è¦ä¸€ä¸ªåœ°æ–¹å­˜å‚¨ä»£ç†å•æ¬¡è¿è¡Œçš„æ‰€æœ‰ä¿¡æ¯ï¼Œè¿™å°±æ˜¯ `State` çš„ä½œç”¨ã€‚å®ƒåƒä¸€ä¸ªä¸­å¤®ç™½æ¿ï¼Œå›¾çš„æ¯ä¸ªéƒ¨åˆ†éƒ½å¯ä»¥è¯»å†™ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Import the base state class from LangGraph from langgraph.graph import MessagesState # Define the central state object for our graph. class State(MessagesState): # This field will hold the initial raw email data. email_input: dict # This field will store the decision made by our triage router. classification_decision: Literal["ignore", "respond", "notify"]
```

ç»§æ‰¿è‡ª LangGraph çš„ `MessagesState`ï¼Œè‡ªåŠ¨è·å¾—ä¸€ä¸ª `messages` åˆ—è¡¨æ¥è·Ÿè¸ªå¯¹è¯å†å²ã€‚ç„¶åæ·»åŠ è‡ªå®šä¹‰å­—æ®µã€‚éšç€æµç¨‹ä»ä¸€ä¸ªèŠ‚ç‚¹ç§»åŠ¨åˆ°å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™ä¸ª `State` å¯¹è±¡ä¼šè¢«ä¼ é€’å¹¶ç´¯ç§¯ä¿¡æ¯ã€‚

æœ€åå®šä¹‰ä¸€ä¸ªå°ä½†é‡è¦çš„ `StateInput` æ¨¡å¼ï¼Œè§„å®šå›¾çš„åˆå§‹è¾“å…¥åº”è¯¥æ˜¯ä»€ä¹ˆæ ·å­ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define a TypedDict for the initial input to our entire workflow. class StateInput(TypedDict): # The workflow must be started with a dictionary containing an 'email_input' key. email_input: dict
```

è¿™ä¸ªç®€å•çš„æ¨¡å¼ä»åº”ç”¨å…¥å£ç‚¹å°±æä¾›äº†æ¸…æ™°æ€§å’Œç±»å‹å®‰å…¨æ€§ï¼Œç¡®ä¿å¯¹å›¾çš„ä»»ä½•è°ƒç”¨éƒ½ä»¥æ­£ç¡®çš„æ•°æ®ç»“æ„å¼€å§‹ã€‚

#### åˆ›å»ºæç¤ºè¯

ä½¿ç”¨æç¤ºè¯æ–¹æ³•æ¥æŒ‡å¯¼å’Œå¼•å¯¼ LLM è¡Œä¸ºã€‚å¯¹äºä»£ç†ï¼Œä¼šå®šä¹‰å‡ ä¸ªæç¤ºè¯ï¼Œæ¯ä¸ªéƒ½æœ‰ç‰¹å®šçš„ä»»åŠ¡ã€‚

ä»£ç†ä»æˆ‘ä»¬è¿™é‡Œå­¦åˆ°ä»»ä½•ä¸œè¥¿ä¹‹å‰ï¼Œéœ€è¦ä¸€å¥—åŸºå‡†æŒ‡ä»¤ã€‚è¿™äº›é»˜è®¤å­—ç¬¦ä¸²ä¼šåœ¨ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶åŠ è½½åˆ°è®°å¿†å­˜å‚¨ä¸­ï¼Œä¸ºä»£ç†è¡Œä¸ºæä¾›èµ·ç‚¹ã€‚

é¦–å…ˆå®šä¹‰ `default_background` ç»™ä»£ç†ä¸€ä¸ªè§’è‰²ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define a default persona for the agent. default_background=""" I'm Lance, a software engineer at LangChain. """
```

æ¥ä¸‹æ¥æ˜¯ `default_triage_instructions`ï¼Œåˆ†ç±»è·¯ç”±å™¨éµå¾ªçš„åˆå§‹è§„åˆ™ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define the initial rules for the triage LLM. default_triage_instructions = """ Emails that are not worth responding to: - Marketing newsletters and promotional emails - Spam or suspicious emails - CC'd on FYI threads with no direct questions Emails that require notification but no response: - Team member out sick or on vacation - Build system notifications or deployments Emails that require a response: - Direct questions from team members - Meeting requests requiring confirmation """
```

ç„¶åæ˜¯ `default_response_preferences`ï¼Œå®šä¹‰ä»£ç†çš„åˆå§‹å†™ä½œé£æ ¼ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define the default preferences for how the agent should compose emails. default_response_preferences = """ Use professional and concise language. If the e-mail mentions a deadline, make sure to explicitly acknowledge and reference the deadline in your response. When responding to meeting scheduling requests: - If times are proposed, verify calendar availability and commit to one. - If no times are proposed, check your calendar and propose multiple options. """
```

æœ€åæ˜¯ `default_cal_preferences`ï¼ŒæŒ‡å¯¼æ—¥ç¨‹å®‰æ’è¡Œä¸ºã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define the default preferences for scheduling meetings. default_cal_preferences = """ 30 minute meetings are preferred, but 15 minute meetings are also acceptable. """
```

ç°åœ¨åˆ›å»ºä½¿ç”¨è¿™äº›é»˜è®¤å€¼çš„æç¤ºè¯ï¼Œé¦–å…ˆæ˜¯ `triage_system_prompt`ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define the system prompt for the initial triage step. triage_system_prompt = """ < Role > Your role is to triage incoming emails based on background and instructions.  Role > < Background > {background}  Background > < Instructions > Categorize each email into IGNORE, NOTIFY, or RESPOND.  Instructions > < Rules > {triage_instructions}  Rules > """
```

è¿™ä¸ªæç¤ºè¯æ¨¡æ¿ç»™åˆ†ç±»è·¯ç”±å™¨æä¾›è§’è‰²å’ŒæŒ‡ä»¤ã€‚`{background}` å’Œ `{triage_instructions}` å ä½ç¬¦ä¼šè¢«åˆšæ‰å®šä¹‰çš„é»˜è®¤å­—ç¬¦ä¸²å¡«å……ã€‚

æ¥ç€æ˜¯ `triage_user_prompt`ï¼Œä¸€ä¸ªç®€å•çš„æ¨¡æ¿ï¼Œç”¨äºå°†åŸå§‹é‚®ä»¶å†…å®¹æ„é€ æˆ LLM æ˜“äºè§£æçš„æ¸…æ™°æ ¼å¼ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define the user prompt for triage, which will format the raw email. triage_user_prompt = """ Please determine how to handle the following email: From: {author} To: {to} Subject: {subject} {email_thread}"""
```

ç°åœ¨æ˜¯ä¸»è¦ç»„ä»¶ï¼Œå¿…é¡»åˆ›å»º `agent_system_prompt_hitl_memory`ï¼Œå®ƒåŒ…å«åˆ°ç›®å‰ä¸ºæ­¢ç¼–ç çš„è§’è‰²å’Œå…¶ä»–æŒ‡ä»¤ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Import the datetime library to include the current date in the prompt. from datetime import datetime # Define the main system prompt for the response agent. agent_system_prompt_hitl_memory = """ < Role > You are a top-notch executive assistant.  Role > < Tools > You have access to the following tools: {tools_prompt}  Tools > < Instructions > 1. Analyze the email content carefully. 2. Always call one tool at a time until the task is complete. 3. Use Question to ask the user for clarification. 4. Draft emails using write_email. 5. For meetings, check availability and schedule accordingly. - Today's date is """ + datetime.now().strftime("%Y-%m-%d") + """ 6. After sending emails, use the Done tool.  Instructions > < Background > {background}  Background > < Response Preferences > {response_preferences}  Response Preferences > < Calendar Preferences > {cal_preferences}  Calendar Preferences > """
```

è¿™æ˜¯ä¸»å“åº”ä»£ç†çš„ä¸»æŒ‡ä»¤é›†ã€‚åƒ `{response_preferences}` å’Œ `{cal_preferences}` è¿™æ ·çš„å ä½ç¬¦æ˜¯è®°å¿†ç³»ç»Ÿçš„å…³é”®ã€‚

> å®ƒä»¬å…è®¸åŠ¨æ€åœ°ä»è®°å¿†å­˜å‚¨ä¸­æ³¨å…¥ä»£ç†å­¦åˆ°çš„çŸ¥è¯†ï¼Œä½¿å…¶èƒ½å¤Ÿéšæ—¶é—´è°ƒæ•´è¡Œä¸ºã€‚

ä¸ºäº†è®©ä»£ç†æ”¹è¿›ï¼Œä¸ºä¸“é—¨çš„"è®°å¿†ç®¡ç†å™¨"LLM å®šä¹‰ç‰¹æ®Šæç¤ºè¯ã€‚å®ƒå”¯ä¸€çš„å·¥ä½œå°±æ˜¯å®‰å…¨ã€æ™ºèƒ½åœ°æ›´æ–°è®°å¿†å­˜å‚¨ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define the system prompt for our specialized memory update manager LLM. MEMORY_UPDATE_INSTRUCTIONS = """ # Role You are a memory profile manager for an email assistant. # Rules - NEVER overwrite the entire profile - ONLY add new information - ONLY update facts contradicted by feedback - PRESERVE all other information # Reasoning Steps 1. Analyze the current memory profile. 2. Review feedback messages. 3. Extract relevant preferences. 4. Compare to existing profile. 5. Identify facts to update. 6. Preserve everything else. 7. Output updated profile. # Process current profile for {namespace}  {current_profile}  """
```

`MEMORY_UPDATE_INSTRUCTIONS` æç¤ºè¯é«˜åº¦ç»“æ„åŒ–ï¼Œè§„åˆ™ä¸¥æ ¼ï¼šæ°¸ä¸è¦†ç›–ã€åªåšé’ˆå¯¹æ€§æ·»åŠ ã€ä¿ç•™ç°æœ‰ä¿¡æ¯ã€‚è¿™ç§æ–¹æ³•å¯¹é˜²æ­¢ä»£ç†è®°å¿†è¢«ç ´åè‡³å…³é‡è¦ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define a reinforcement prompt to remind the LLM of the most critical rules. MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT = """ Remember: - NEVER overwrite the entire profile - ONLY make targeted additions - ONLY update specific facts contradicted by feedback - PRESERVE all other information """
```

`MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT` æ˜¯ç°ä»£æç¤ºè¯å·¥ç¨‹æŠ€æœ¯ã€‚å®ƒæ˜¯è¦æ±‚ LLM æ›´æ–°è®°å¿†æ—¶ä¼šé™„åŠ åˆ°æ¶ˆæ¯ä¸­çš„æœ€å…³é”®è§„åˆ™çš„ç®€æ˜æ‘˜è¦ã€‚é‡å¤å…³é”®æŒ‡ä»¤æœ‰åŠ©äºç¡®ä¿ LLM éµå®ˆå®ƒä»¬ã€‚

#### å®šä¹‰å·¥å…·å’Œå®ç”¨å‡½æ•°

ä»£ç†æœ‰äº†æŒ‡ä»¤ï¼Œç°åœ¨éœ€è¦èµ‹äºˆå®ƒé‡‡å–è¡ŒåŠ¨çš„èƒ½åŠ›ã€‚ä¼šå®šä¹‰ä½œä¸ºå·¥å…·çš„ Python å‡½æ•°ï¼Œä»¥åŠä¸€äº›è¾…åŠ©å®ç”¨å‡½æ•°ï¼Œä¿æŒä¸»ä»£ç æ•´æ´æœ‰åºã€‚

ç¼–å†™å®é™…å·¥å…·å‡½æ•°ä¹‹å‰ï¼Œéœ€è¦ä¸€ä¸ªå…³äºå®ƒä»¬çš„ç®€å•æ–‡æœ¬æè¿°ã€‚è¿™æ˜¯ä»£ç†åœ¨ä¸»æç¤ºè¯ä¸­ä¼š"çœ‹åˆ°"çš„å†…å®¹ï¼Œè®©å®ƒç†è§£æœ‰å“ªäº›å·¥å…·å¯ç”¨ä»¥åŠå¦‚ä½•ä½¿ç”¨ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # A simple string describing the available tools for the LLM. HITL_MEMORY_TOOLS_PROMPT = """ 1. write_email(to, subject, content) - Send emails to specified recipients 2. schedule_meeting(attendees, subject, duration_minutes, preferred_day, start_time) - Schedule calendar meetings 3. check_calendar_availability(day) - Check available time slots 4. Question(content) - Ask follow-up questions 5. Done - Mark the email as sent """
```

è¿™ä¸ªå­—ç¬¦ä¸²æœ¬èº«ä¸æ˜¯å¯æ‰§è¡Œä»£ç ï¼Œè€Œæ˜¯ä½œä¸º LLM çš„æ–‡æ¡£ã€‚å®ƒä¼šè¢«æ’å…¥åˆ°ä¸» `agent_system_prompt_hitl_memory` ä¸­çš„ `{tools_prompt}` å ä½ç¬¦ã€‚è¿™æ ·ä»£ç†å°±çŸ¥é“ `write_email` å‡½æ•°å­˜åœ¨ï¼Œéœ€è¦ `to`ã€`subject` å’Œ `content` å‚æ•°ã€‚

å¥½çš„é¡¹ç›®éƒ½æœ‰ä¸€ä¸ª `utils.py` æ–‡ä»¶æ¥å­˜æ”¾æ‰§è¡Œå¸¸è§ã€é‡å¤æ€§ä»»åŠ¡çš„è¾…åŠ©å‡½æ•°ï¼Œä¿æŒä¸»å›¾é€»è¾‘æ•´æ´ï¼Œä¸“æ³¨äºå·¥ä½œæµæœ¬èº«ã€‚

é¦–å…ˆéœ€è¦ä¸€ä¸ªå‡½æ•°æ¥è§£æåˆå§‹é‚®ä»¶è¾“å…¥ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # This utility unpacks the email input dictionary for easier access. def parse_email(email_input: dict) -> tuple[str, str, str, str]: """Parse an email input dictionary into its constituent parts.""" # Return a tuple containing the author, recipient, subject, and body of the email. return ( email_input["author"], email_input["to"], email_input["subject"], email_input["email_thread"], )
```

`parse_email` å‡½æ•°æ˜¯è¾“å…¥å­—å…¸çš„ç®€å•è§£åŒ…å™¨ã€‚è™½ç„¶å¯ä»¥åœ¨å›¾èŠ‚ç‚¹ä¸­ç›´æ¥è®¿é—® `email_input["author"]`ï¼Œä½†è¿™ä¸ªè¾…åŠ©å‡½æ•°è®©ä»£ç æ›´å¯è¯»ï¼Œå¹¶é›†ä¸­äº†è§£æé€»è¾‘ã€‚

æ¥ä¸‹æ¥ï¼Œä¸€ä¸ªå°†é‚®ä»¶å†…å®¹æ ¼å¼åŒ–ä¸º Markdown ä¾› LLM ä½¿ç”¨çš„å‡½æ•°ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # This function formats the raw email data into clean markdown for the LLM. def format_email_markdown(subject, author, to, email_thread): """Format email details into a nicely formatted markdown string.""" # Use f-string formatting to create a structured string with clear labels. return f""" **Subject**: {subject} **From**: {author} **To**: {to} {email_thread} --- """
```

`format_email_markdown` å‡½æ•°æ¥æ”¶è§£æåçš„é‚®ä»¶éƒ¨åˆ†ï¼Œå°†å®ƒä»¬æ’åˆ—æˆå¹²å‡€çš„ Markdown æ ¼å¼å—ã€‚è¿™ç§ç»“æ„åŒ–æ ¼å¼æ¯”åŸå§‹çš„éç»“æ„åŒ–å­—ç¬¦ä¸²æ›´å®¹æ˜“è¢« LLM è§£æï¼Œå¸®åŠ©å®ƒæ›´å¥½åœ°ç†è§£é‚®ä»¶çš„ä¸åŒç»„æˆéƒ¨åˆ†ï¼ˆå‘ä»¶äººã€ä¸»é¢˜ã€æ­£æ–‡ï¼‰ã€‚

æœ€åéœ€è¦ä¸€ä¸ªå‡½æ•°ä¸ºäººå·¥å®¡é˜…è€…æ ¼å¼åŒ–ä»£ç†å»ºè®®çš„æ“ä½œã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # This function creates a human-friendly view of a tool call for the HITL interface. def format_for_display(tool_call: dict) -> str: """Format a tool call into a readable string for the user.""" # Initialize an empty string to build our display. display = "" # Use conditional logic to create custom, readable formats for our main tools. if tool_call["name"] == "write_email": display += f'# Email Draft\n\n**To**: {tool_call["args"].get("to")}\n**Subject**: {tool_call["args"].get("subject")}\n\n{tool_call["args"].get("content")}' elif tool_call["name"] == "schedule_meeting": display += f'# Calendar Invite\n\n**Meeting**: {tool_call["args"].get("subject")}\n**Attendees**: {", ".join(tool_call["args"].get("attendees"))}' elif tool_call["name"] == "Question": display += f'# Question for User\n\n{tool_call["args"].get("content")}' # Provide a generic fallback for any other tools. else: display += f'# Tool Call: {tool_call["name"]}\n\nArguments:\n{tool_call["args"]}' # Return the final formatted string. return display
```

è¿™ä¸ª `format_for_display` å‡½æ•°å¯¹äººæœºåä½œï¼ˆHITLï¼‰æ­¥éª¤å¾ˆé‡è¦ã€‚å½“ä»£ç†æå‡ºå·¥å…·è°ƒç”¨å¦‚ `write_email` æ—¶ï¼Œä¸æƒ³å‘äººå·¥å®¡é˜…è€…å±•ç¤ºåŸå§‹ JSON å¯¹è±¡ã€‚

è¿™ä¸ªå‡½æ•°å°†æŠ€æœ¯è¡¨ç¤ºè½¬æ¢ä¸ºçœ‹èµ·æ¥åƒå®é™…é‚®ä»¶è‰ç¨¿æˆ–æ—¥å†é‚€è¯·çš„å†…å®¹ï¼Œè®©ç”¨æˆ·æ›´å®¹æ˜“å®¡é˜…ã€ç¼–è¾‘æˆ–æ‰¹å‡†ã€‚

æ¨¡å¼ã€æç¤ºè¯å’Œå®ç”¨å‡½æ•°éƒ½å®šä¹‰å¥½äº†ï¼Œç°åœ¨å¯ä»¥å°†å®ƒä»¬ç»„è£…æˆå®Œæ•´çš„å›¾ï¼Œè®©å­¦ä¹ ä»£ç†è¿è½¬èµ·æ¥ã€‚

### è®°å¿†åŠŸèƒ½ä¸å›¾èŠ‚ç‚¹

ä»è¿™é‡Œå¼€å§‹æˆ‘ä»¬å°±è¦å®ç°è®°å¿†é€»è¾‘äº†ï¼Œå…ˆçœ‹çœ‹æ•´ä¸ªç³»ç»Ÿå¦‚ä½•è¿ä½œã€‚

ä»£ç†ä»é™æ€æŒ‡ä»¤é›†è½¬å˜ä¸ºèƒ½å¤Ÿå­¦ä¹ çš„åŠ¨æ€ç³»ç»Ÿï¼Œå…³é”®å°±åœ¨è¿™é‡Œã€‚

æ„å»ºä½¿ç”¨è®°å¿†çš„å›¾èŠ‚ç‚¹ä¹‹å‰ï¼Œéœ€è¦å®é™…ä¸ `InMemoryStore` äº¤äº’çš„å‡½æ•°ã€‚æˆ‘ä»¬éœ€è¦åˆ›å»ºä¸¤ä¸ªå…³é”®å‡½æ•°ï¼šä¸€ä¸ªè·å–ç°æœ‰åå¥½ï¼Œå¦ä¸€ä¸ªæ ¹æ®åé¦ˆæ›´æ–°å®ƒä»¬ã€‚

é¦–å…ˆéœ€è¦å¯é çš„æ–¹å¼ä»å­˜å‚¨ä¸­è·å–åå¥½ã€‚ç¼–å†™ä¸€ä¸ªå« `get_memory` çš„å‡½æ•°ï¼Œå®ƒä¼šåœ¨å­˜å‚¨ä¸­æŸ¥æ‰¾ç‰¹å®šåå¥½ï¼ˆå¦‚ `"triage_preferences"`ï¼‰ã€‚æ‰¾åˆ°å°±è¿”å›å­˜å‚¨çš„å€¼ã€‚

å¦‚æœæ‰¾ä¸åˆ°â€”â€”è¿™ä¼šåœ¨ç”¨æˆ·ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶å‘ç”Ÿâ€”â€”å®ƒä¼šä½¿ç”¨ä¹‹å‰å®šä¹‰çš„é»˜è®¤å†…å®¹åˆ›å»ºæ¡ç›®ã€‚è¿™ç¡®ä¿ä»£ç†å§‹ç»ˆæœ‰ä¸€å¥—è§„åˆ™å¯ä»¥éµå¾ªã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # A function to retrieve memory from the store or initialize with defaults. def get_memory(store, namespace, default_content=None): """Get memory from the store or initialize with default if it doesn't exist.""" # Use the store's .get() method to search for an item with a specific key. user_preferences = store.get(namespace, "user_preferences") # If the item exists, return its value (the stored string). if user_preferences: return user_preferences.value # If the item does not exist, this is the first time we're accessing this memory. else: # Use the store's .put() method to create the memory item with default content. store.put(namespace, "user_preferences", default_content) # Return the default content to be used in this run. return default_content
```

è¿™ä¸ªç®€å•çš„å‡½æ•°åŠŸèƒ½å¼ºå¤§ã€‚å®ƒæŠ½è±¡äº†æ£€æŸ¥å’Œåˆå§‹åŒ–è®°å¿†çš„é€»è¾‘ã€‚å›¾ä¸­çš„ä»»ä½•èŠ‚ç‚¹ç°åœ¨éƒ½å¯ä»¥è°ƒç”¨ `get_memory` è·å–æœ€æ–°çš„ç”¨æˆ·åå¥½ï¼Œæ— éœ€çŸ¥é“è¿™æ˜¯ç¬¬ä¸€æ¬¡è¿è¡Œè¿˜æ˜¯ç¬¬ä¸€ç™¾æ¬¡ã€‚

è¿™é‡Œæ˜¯ä»£ç†å­¦ä¹ è¢«è§¦å‘çš„åœ°æ–¹ã€‚`update_memory` å‡½æ•°è®¾è®¡ç”¨æ¥æ¥æ”¶ç”¨æˆ·åé¦ˆâ€”â€”æ¯”å¦‚ç¼–è¾‘è¿‡çš„é‚®ä»¶æˆ–è‡ªç„¶è¯­è¨€æŒ‡ä»¤â€”â€”å¹¶ç”¨å®ƒæ¥ç²¾ç‚¼ä»£ç†å­˜å‚¨çš„çŸ¥è¯†ã€‚å®ƒä½¿ç”¨ä¹‹å‰ç²¾å¿ƒåˆ¶ä½œçš„ `MEMORY_UPDATE_INSTRUCTIONS` æç¤ºè¯æ¥åè°ƒä¸€ä¸ªç‰¹æ®Šç”¨é€”çš„ LLM è°ƒç”¨ã€‚

ä¸ºç¡®ä¿ LLM è¾“å‡ºå¯é¢„æµ‹ï¼Œå…ˆå®šä¹‰ä¸€ä¸ª `UserPreferences` Pydantic æ¨¡å¼ã€‚è¿™ä¼šå¼ºåˆ¶è®°å¿†ç®¡ç†å™¨ LLM è¿”å›ä¸€ä¸ª JSON å¯¹è±¡ï¼ŒåŒ…å«æ¨ç†è¿‡ç¨‹å’Œæœ€ç»ˆæ›´æ–°çš„åå¥½å­—ç¬¦ä¸²ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # A Pydantic model to structure the output of our memory update LLM call. class UserPreferences(BaseModel): """Updated user preferences based on user's feedback.""" # A field for the LLM to explain its reasoning, useful for debugging. chain_of_thought: str = Field(description="Reasoning about which user preferences need to add / update if required") # The final, updated string of user preferences. user_preferences: str = Field(description="Updated user preferences")
```

ç°åœ¨å¯ä»¥ç¼–å†™ `update_memory` å‡½æ•°æœ¬èº«ã€‚å®ƒä¼šæ£€ç´¢å½“å‰åå¥½ï¼Œå°†å®ƒä»¬ä¸ç”¨æˆ·åé¦ˆå’Œç‰¹æ®Šæç¤ºè¯ç»“åˆï¼Œç„¶åå°† LLM çš„ç²¾ç‚¼è¾“å‡ºä¿å­˜å›å­˜å‚¨ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Import AIMessage to help filter messages before sending them to the memory updater. from langchain_core.messages import AIMessage # This function intelligently updates the memory store based on user feedback. def update_memory(store, namespace, messages): """Update memory profile in the store.""" # First, get the current memory from the store so we can provide it as context. user_preferences = store.get(namespace, "user_preferences") # Initialize a new LLM instance specifically for this task, configured for structured output. memory_updater_llm = llm.with_structured_output(UserPreferences) # This is a small but important fix: filter out any previous AI messages with tool calls. # Passing these complex objects can sometimes cause errors in the downstream LLM call. messages_to_send = [ msg for msg in messages if not (isinstance(msg, AIMessage) and hasattr(msg, 'tool_calls') and msg.tool_calls) ] # Invoke the LLM with the memory prompt, current preferences, and the user's feedback. result = memory_updater_llm.invoke( [ # The system prompt that instructs the LLM on how to update memory. {"role": "system", "content": MEMORY_UPDATE_INSTRUCTIONS.format(current_profile=user_preferences.value, namespace=namespace)}, ] # Append the filtered conversation messages containing the feedback. + messages_to_send ) # Save the newly generated preference string back into the store, overwriting the old one. store.put(namespace, "user_preferences", result.user_preferences)
```

è¿™ä¸ªå‡½æ•°æ˜¯ä»£ç†å­¦ä¹ èƒ½åŠ›çš„ä¸»è¦ç»„æˆéƒ¨åˆ†ã€‚é€šè¿‡ä½¿ç”¨å¸¦æœ‰ä¸¥æ ¼æŒ‡ä»¤çš„ä¸“ç”¨ LLM è°ƒç”¨ï¼Œç¡®ä¿è®°å¿†ä»¥å—æ§å’Œå¢é‡æ–¹å¼æ›´æ–°ï¼Œè®©ä»£ç†éšæ—¶é—´é€æ¸ä¸ç”¨æˆ·åå¥½å¯¹é½ã€‚

ç°åœ¨å¯ä»¥å®šä¹‰ä»£ç†çš„æ ¸å¿ƒé€»è¾‘ã€‚åœ¨ LangGraph ä¸­ï¼Œè¿™ä¸ªé€»è¾‘å°è£…åœ¨èŠ‚ç‚¹ä¸­ã€‚æ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯ä¸€ä¸ª Python å‡½æ•°ï¼Œæ¥æ”¶å›¾çš„å½“å‰ `State`ï¼Œæ‰§è¡Œæ“ä½œï¼Œè¿”å›å¯¹è¯¥çŠ¶æ€çš„æ›´æ–°ã€‚

> ç”µå­é‚®ä»¶åŠ©æ‰‹ä¼šæœ‰å‡ ä¸ªå…³é”®èŠ‚ç‚¹ï¼Œå¤„ç†ä»åˆå§‹åˆ†ç±»åˆ°ç”Ÿæˆæœ€ç»ˆå“åº”çš„æ‰€æœ‰äº‹æƒ…ã€‚

å·¥ä½œæµä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹æ˜¯ `triage_router`ã€‚è¿™ä¸ªå‡½æ•°çš„ä»»åŠ¡æ˜¯å¯¹æ”¶åˆ°çš„é‚®ä»¶åšåˆæ­¥å†³å®šâ€¦â€¦

> åº”è¯¥å›å¤ã€åªé€šçŸ¥ç”¨æˆ·ï¼Œè¿˜æ˜¯å®Œå…¨å¿½ç•¥ï¼Ÿé•¿æœŸè®°å¿†é¦–æ¬¡å‘æŒ¥ä½œç”¨å°±åœ¨è¿™é‡Œã€‚

è·¯ç”±å™¨ä¼šä½¿ç”¨ `get_memory` å‡½æ•°è·å–ç”¨æˆ·æœ€æ–°çš„ `triage_preferences` å¹¶æ³¨å…¥åˆ°æç¤ºè¯ä¸­ï¼Œç¡®ä¿å†³ç­–èƒ½åŠ›éšæ—¶é—´æé«˜ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Import the Command class for routing and BaseStore for type hinting from langgraph.types import Command from langgraph.store.base import BaseStore # Define the first node in our graph, the triage router. def triage_router(state: State, store: BaseStore) -> Command: """Analyze email content to decide the next step.""" # Unpack the raw email data using our utility function. author, to, subject, email_thread = parse_email(state["email_input"]) # Format the email content into a clean string for the LLM. email_markdown = format_email_markdown(subject, author, to, email_thread) # Here is the memory integration: fetch the latest triage instructions. # If they don't exist, it will use the `default_triage_instructions`. triage_instructions = get_memory(store, ("email_assistant", "triage_preferences"), default_triage_instructions) # Format the system prompt, injecting the retrieved triage instructions. system_prompt = triage_system_prompt.format( background=default_background, triage_instructions=triage_instructions, ) # Format the user prompt with the specific details of the current email. user_prompt = triage_user_prompt.format( author=author, to=to, subject=subject, email_thread=email_thread ) # Invoke the LLM router, which is configured to return our `RouterSchema`. result = llm_router.invoke( [ {"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}, ] ) # Based on the LLM's classification, decide which node to go to next. if result.classification == "respond": print("ğŸ“§ Classification: RESPOND - This email requires a response") # Set the next node to be the 'response_agent'. goto = "response_agent" # Update the state with the decision and the formatted email for the agent. update = { "classification_decision": result.classification, "messages": [{"role": "user", "content": f"Respond to the email: {email_markdown}"}], } elif result.classification == "ignore": print("ğŸš« Classification: IGNORE - This email can be safely ignored") # End the workflow immediately. goto = END # Update the state with the classification decision. update = {"classification_decision": result.classification} elif result.classification == "notify": print("ğŸ”” Classification: NOTIFY - This email contains important information") # Go to the human-in-the-loop handler for notification. goto = "triage_interrupt_handler" # Update the state with the classification decision. update = {"classification_decision": result.classification} else: # Raise an error if the classification is invalid. raise ValueError(f"Invalid classification: {result.classification}") # Return a Command object to tell LangGraph where to go next and what to update. return Command(goto=goto, update=update)
```

è¿™ä¸ªèŠ‚ç‚¹æ˜¯æ•´ä¸ªç³»ç»Ÿçš„å…¥å£ã€‚é€šè¿‡æ·»åŠ ä¸€è¡Œ `triage_instructions = get_memory(...)`ï¼Œå°±æŠŠå®ƒä»é™æ€è·¯ç”±å™¨å˜æˆäº†èƒ½å­¦ä¹ çš„è·¯ç”±å™¨ã€‚å½“ç”¨æˆ·å¯¹åˆ†ç±»å†³ç­–æä¾›åé¦ˆæ—¶ï¼Œå­˜å‚¨ä¸­çš„ `triage_preferences` ä¼šè¢«æ›´æ–°ï¼Œè¿™ä¸ªèŠ‚ç‚¹å°±ä¼šè‡ªåŠ¨å¼€å§‹åœ¨æœªæ¥çš„é‚®ä»¶ä¸Šåšå‡ºæ›´å¥½ã€æ›´ä¸ªæ€§åŒ–çš„åˆ†ç±»ã€‚

é‚®ä»¶è¢«åˆ†ç±»ä¸º "respond" æ—¶ï¼Œä¼šè¢«ä¼ é€’ç»™ä¸»å“åº”ä»£ç†ã€‚è¯¥ä»£ç†çš„æ ¸å¿ƒæ˜¯ `llm_call` èŠ‚ç‚¹ã€‚è¿™ä¸ªå‡½æ•°çš„ç›®çš„æ˜¯è·å–å½“å‰å¯¹è¯å†å²å¹¶é‡‡å–ä¸‹ä¸€æ­¥è¡ŒåŠ¨ï¼Œé€šå¸¸æ˜¯å†³å®šè°ƒç”¨å“ªä¸ªå·¥å…·ã€‚

è·Ÿåˆ†ç±»è·¯ç”±å™¨ä¸€æ ·ï¼Œè¿™ä¸ªèŠ‚ç‚¹é›†æˆäº†è®°å¿†æ¥æŒ‡å¯¼å†³ç­–ã€‚å®ƒè·å– `response_preferences` å’Œ `cal_preferences`ï¼Œç¡®ä¿è¡Œä¸ºä¸ç”¨æˆ·å­¦åˆ°çš„é£æ ¼ä¿æŒä¸€è‡´ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # This is the primary reasoning node for the response agent. def llm_call(state: State, store: BaseStore): """LLM decides whether to call a tool or not, using stored preferences.""" # Fetch the user's latest calendar preferences from the memory store. cal_preferences = get_memory(store, ("email_assistant", "cal_preferences"), default_cal_preferences) # Fetch the user's latest response (writing style) preferences. response_preferences = get_memory(store, ("email_assistant", "response_preferences"), default_response_preferences) # Filter out previous AI messages with tool calls to prevent API errors. messages_to_send = [ msg for msg in state["messages"] if not (isinstance(msg, AIMessage) and hasattr(msg, 'tool_calls') and msg.tool_calls) ] # Invoke the main LLM, which is bound to our set of tools. # The prompt is formatted with the preferences retrieved from memory. response = llm_with_tools.invoke( [ {"role": "system", "content": agent_system_prompt_hitl_memory.format( tools_prompt=HITL_MEMORY_TOOLS_PROMPT, background=default_background, response_preferences=response_preferences, cal_preferences=cal_preferences )} ] + messages_to_send ) # Return the LLM's response to be added to the state. return {"messages": [response]}
```

è¿™ä¸ªèŠ‚ç‚¹å±•ç¤ºäº†é•¿æœŸè®°å¿†çš„é‡è¦æ€§ã€‚æ¯æ¬¡æ‰§è¡Œæ—¶éƒ½ä¼šæå–ç”¨æˆ·æœ€æ–°çš„å†™ä½œé£æ ¼å’Œæ—¥å†åå¥½ã€‚

å½“ç”¨æˆ·æä¾›åé¦ˆè¯´æ›´å–œæ¬¢è¾ƒçŸ­çš„é‚®ä»¶æˆ– 30 åˆ†é’Ÿçš„ä¼šè®®æ—¶ï¼Œ`update_memory` å‡½æ•°ä¼šä¿®æ”¹å­˜å‚¨ã€‚ä¸‹æ¬¡è¿™ä¸ª `llm_call` èŠ‚ç‚¹è¿è¡Œæ—¶ï¼Œä¼šè‡ªåŠ¨è·å–é‚£äº›æ–°åå¥½å¹¶æ³¨å…¥åˆ°æç¤ºè¯ä¸­ï¼Œç«‹å³æ”¹å˜ä»£ç†è¡Œä¸ºï¼Œæ— éœ€ä»»ä½•ä»£ç æ›´æ”¹ã€‚

è¿™å°±åˆ›å»ºäº†ä¸€ä¸ªåé¦ˆå¾ªç¯ï¼Œä»£ç†åœ¨å…¶ä¸­ä¸æ–­é€‚åº”ç”¨æˆ·ã€‚

### é€šè¿‡äººæœºåä½œæ•è·åé¦ˆ

ä»£ç†ä¸ä»…ä»…æ˜¯åœ¨è¡ŒåŠ¨ï¼Œè¿˜å¾—çŸ¥é“ä½•æ—¶è¯·æ±‚å¸®åŠ©æˆ–ç¡®è®¤ã€‚æ¥ä¸‹æ¥è¦æ„å»ºçš„èŠ‚ç‚¹é›†æ˜¯ä¸­æ–­å¤„ç†å™¨ã€‚

è¿™äº›ç‰¹æ®ŠèŠ‚ç‚¹ä¼šæš‚åœå›¾çš„æ‰§è¡Œå¹¶ç­‰å¾…äººç±»è¾“å…¥ã€‚ç¥å¥‡çš„åœ°æ–¹å°±å‘ç”Ÿåœ¨è¿™é‡Œï¼šåœ¨è¿™äº›æ­¥éª¤ä¸­æä¾›çš„åé¦ˆä¼šè¢«æ•è·å¹¶ç”¨äºæ›´æ–°ä»£ç†çš„é•¿æœŸè®°å¿†ã€‚

ä¼šæœ‰ä¸¤ä¸ªä¸­æ–­ç‚¹ï¼š

ä¸€ä¸ªåœ¨åˆå§‹åˆ†ç±»ä¹‹åï¼ˆç”¨äº `notify` åˆ†ç±»ï¼‰ï¼Œå¦ä¸€ä¸ªæ›´å¤æ‚ï¼Œç”¨äºå®¡æŸ¥ä»£ç†å»ºè®®çš„å·¥å…·è°ƒç”¨ã€‚

é¦–å…ˆæ„å»º `triage_interrupt_handler`ã€‚å½“ `triage_router` å°†é‚®ä»¶åˆ†ç±»ä¸º `notify` æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹è¢«è§¦å‘ã€‚ä»£ç†ä¸ä¼šå¯¹é‚®ä»¶é‡‡å–è¡ŒåŠ¨ï¼Œè€Œæ˜¯å‘ˆç°ç»™ç”¨æˆ·å¹¶è¯·æ±‚å†³ç­–ï¼š

> åº”è¯¥å¿½ç•¥ï¼Œè¿˜æ˜¯å®é™…å›å¤ï¼Ÿç”¨æˆ·åœ¨è¿™é‡Œçš„é€‰æ‹©æ˜¯å…³äºåˆ†ç±»åå¥½çš„å®è´µåé¦ˆã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Import the `interrupt` function from LangGraph. from langgraph.types import interrupt # Define the interrupt handler for the triage step. def triage_interrupt_handler(state: State, store: BaseStore) -> Command: """Handles interrupts from the triage step, pausing for user input.""" # Parse the email input to format it for display. author, to, subject, email_thread = parse_email(state["email_input"]) email_markdown = format_email_markdown(subject, author, to, email_thread) # This is the data structure that defines the interrupt. # It specifies the action, the allowed user responses, and the content to display. request = { "action_request": { "action": f"Email Assistant: {state['classification_decision']}", "args": {} }, "config": { "allow_ignore": True, "allow_respond": True }, "description": email_markdown, } # The `interrupt()` function pauses the graph and sends the request to the user. # It waits here until it receives a response. response = interrupt([request])[0] # Now, we process the user's response. if response["type"] == "response": # The user decided to respond, overriding the 'notify' classification. user_input = response["args"] # We create a message to pass to the memory updater. messages = [{"role": "user", "content": f"The user decided to respond to the email, so update the triage preferences to capture this."}] # This is a key step: we call `update_memory` to teach the agent. update_memory(store, ("email_assistant", "triage_preferences"), messages) # Prepare to route to the main response agent. goto = "response_agent" # Update the state with the user's feedback. update = {"messages": [{"role": "user", "content": f"User wants to reply. Use this feedback: {user_input}"}]} elif response["type"] == "ignore": # The user confirmed the email should be ignored. messages = [{"role": "user", "content": f"The user decided to ignore the email even though it was classified as notify. Update triage preferences to capture this."}] # We still update memory to reinforce this preference. update_memory(store, ("email_assistant", "triage_preferences"), messages) # End the workflow. goto = END update = {} # No message update needed. else: raise ValueError(f"Invalid response: {response}") # Return a Command to direct the graph's next step. return Command(goto=goto, update=update)
```

å¦‚æœä»£ç†è®¤ä¸ºä¸€å°é‚®ä»¶åªæ˜¯é€šçŸ¥ï¼Œä½†ç”¨æˆ·å†³å®šå›å¤ï¼Œ`update_memory` å°±ä¼šè¢«è°ƒç”¨ã€‚è®°å¿†ç®¡ç†å™¨ LLM ä¼šçœ‹åˆ°æ¶ˆæ¯"ç”¨æˆ·å†³å®šå›å¤..."å¹¶åˆ†æé‚®ä»¶å†…å®¹ã€‚

ç„¶åå®ƒä¼šç²¾ç¡®åœ°æ›´æ–° `triage_preferences` å­—ç¬¦ä¸²ï¼Œä¹Ÿè®¸é€šè¿‡å°†"æ„å»ºç³»ç»Ÿé€šçŸ¥"ä» `NOTIFY` ç±»åˆ«ç§»åŠ¨åˆ° `RESPOND` ç±»åˆ«ã€‚ä¸‹æ¬¡ç±»ä¼¼é‚®ä»¶åˆ°è¾¾æ—¶ï¼Œ`triage_router` ä¼šåšå‡ºæ›´å¥½ã€æ›´ä¸ªæ€§åŒ–çš„å†³å®šã€‚

ä½†è¿˜éœ€è¦ä¸€ä¸ªä¸»ä¸­æ–­å¤„ç†å™¨ï¼Œè¿™æ˜¯å›¾ä¸­æœ€å¤æ‚çš„èŠ‚ç‚¹ã€‚`llm_call` èŠ‚ç‚¹æå‡ºè¦ä½¿ç”¨çš„å·¥å…·ï¼ˆå¦‚ `write_email` æˆ– `schedule_meeting`ï¼‰åï¼Œè¿™ä¸ª `interrupt_handler` å°±ä¼šä»‹å…¥ã€‚å®ƒå°†ä»£ç†å»ºè®®çš„æ“ä½œå‘ˆç°ç»™ç”¨æˆ·å®¡æŸ¥ã€‚

ç„¶åç”¨æˆ·å¯ä»¥æ¥å—ã€å¿½ç•¥ã€æä¾›è‡ªç„¶è¯­è¨€åé¦ˆæˆ–ç›´æ¥ç¼–è¾‘ã€‚æ¯ç§é€‰æ‹©éƒ½ä¸ºè®°å¿†ç³»ç»Ÿæä¾›äº†ä¸åŒä¸”æœ‰ä»·å€¼çš„ä¿¡å·ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # The main interrupt handler for reviewing tool calls. def interrupt_handler(state: State, store: BaseStore) -> Command: """Creates an interrupt for human review of tool calls and updates memory.""" # We'll build up a list of new messages to add to the state. result = [] # By default, we'll loop back to the LLM after this. goto = "llm_call" # The agent can propose multiple tool calls, so we loop through them. for tool_call in state["messages"][-1].tool_calls: # We only want to interrupt for certain "high-stakes" tools. hitl_tools = ["write_email", "schedule_meeting", "Question"] if tool_call["name"] not in hitl_tools: # For other tools (like check_calendar), execute them without interruption. tool = tools_by_name[tool_call["name"]] observation = tool.invoke(tool_call["args"]) result.append({"role": "tool", "content": observation, "tool_call_id": tool_call["id"]}) continue # Format the proposed action for display to the human reviewer. tool_display = format_for_display(tool_call) # Define the interrupt request payload. request = { "action_request": {"action": tool_call["name"], "args": tool_call["args"]}, "config": { "allow_ignore": True, "allow_respond": True, "allow_edit": True, "allow_accept": True }, "description": tool_display, } # Pause the graph and wait for the user's response. response = interrupt([request])[0] # --- MEMORY UPDATE LOGIC BASED ON USER RESPONSE --- if response["type"] == "edit": # The user directly edited the agent's proposed action. initial_tool_call = tool_call["args"] edited_args = response["args"]["args"] # This is the most direct form of feedback. We call `update_memory`. if tool_call["name"] == "write_email": update_memory(store, ("email_assistant", "response_preferences"), [{"role": "user", "content": f"User edited the email. Initial draft: {initial_tool_call}. Edited draft: {edited_args}."}]) elif tool_call["name"] == "schedule_meeting": update_memory(store, ("email_assistant", "cal_preferences"), [{"role": "user", "content": f"User edited the meeting. Initial invite: {initial_tool_call}. Edited invite: {edited_args}."}]) # Execute the tool with the user's edited arguments. tool = tools_by_name[tool_call["name"]] observation = tool.invoke(edited_args) result.append({"role": "tool", "content": observation, "tool_call_id": tool_call["id"]}) elif response["type"] == "response": # The user gave natural language feedback. user_feedback = response["args"] # We capture this feedback and use it to update memory. if tool_call["name"] == "write_email": update_memory(store, ("email_assistant", "response_preferences"), [{"role": "user", "content": f"User gave feedback on the email draft: {user_feedback}"}]) elif tool_call["name"] == "schedule_meeting": update_memory(store, ("email_assistant", "cal_preferences"), [{"role": "user", "content": f"User gave feedback on the meeting invite: {user_feedback}"}]) # We don't execute the tool. Instead, we pass the feedback back to the agent. result.append({"role": "tool", "content": f"User gave feedback: {user_feedback}", "tool_call_id": tool_call["id"]}) elif response["type"] == "ignore": # The user decided this action should not be taken. This is triage feedback. update_memory(store, ("email_assistant", "triage_preferences"), [{"role": "user", "content": f"User ignored the proposal to {tool_call['name']}. This email should not have been classified as 'respond'."}]) result.append({"role": "tool", "content": "User ignored this. End the workflow.", "tool_call_id": tool_call["id"]}) goto = END elif response["type"] == "accept": # The user approved the action. No memory update is needed. tool = tools_by_name[tool_call["name"]] observation = tool.invoke(tool_call["args"]) result.append({"role": "tool", "content": observation, "tool_call_id": tool_call["id"]}) # Return a command with the next node and the messages to add to the state. return Command(goto=goto, update={"messages": result})
```

è¿™ä¸ªèŠ‚ç‚¹æ˜¯å­¦ä¹ ç³»ç»Ÿçš„æ ¸å¿ƒã€‚æ³¨æ„åˆ°æ²¡æœ‰ï¼Œæ¯ç§ç±»å‹çš„ç”¨æˆ·åé¦ˆâ€”â€”ç¼–è¾‘ã€å“åº”å’Œå¿½ç•¥â€”â€”éƒ½ä¼šè§¦å‘å¯¹ `update_memory` çš„è°ƒç”¨ï¼Œå¹¶å¸¦æœ‰ç‰¹å®šçš„ã€ä¸Šä¸‹æ–‡ç›¸å…³çš„æ¶ˆæ¯ã€‚

å½“ç”¨æˆ·å°†ä¼šè®®æ—¶é•¿ä» 45 åˆ†é’Ÿç¼–è¾‘ä¸º 30 åˆ†é’Ÿæ—¶ï¼Œè®°å¿†ç®¡ç†å™¨ LLM ä¼šçœ‹åˆ°è¿™ä¸ªæ˜ç¡®ä¿¡å·ï¼Œå¹¶æ›´æ–° `cal_preferences` ä»¥åœ¨æœªæ¥åå¥½ 30 åˆ†é’Ÿçš„ä¼šè®®ã€‚å½“ç”¨æˆ·è¯´"è®©å®ƒä¸é‚£ä¹ˆæ­£å¼"æ—¶ï¼ŒLLM ä¼šå¯¹æ­¤è¿›è¡Œæ¦‚æ‹¬ï¼Œå¹¶åœ¨ `response_preferences` ä¸­æ·»åŠ æ–°è§„åˆ™ã€‚è¿™ç§æŒç»­ã€ç»†ç²’åº¦çš„åé¦ˆå¾ªç¯è®©ä»£ç†èƒ½å¤Ÿéšæ—¶é—´æˆä¸ºé«˜åº¦ä¸ªæ€§åŒ–çš„åŠ©æ‰‹ã€‚

### ç»„è£…æˆå·¥ä½œæµ

ä»£ç†çš„æ‰€æœ‰å•ç‹¬ç»„ä»¶éƒ½æ„å»ºå¥½äº†ï¼šæ¨¡å¼ã€æç¤ºè¯ã€å·¥å…·ã€å®ç”¨å‡½æ•°å’Œå›¾èŠ‚ç‚¹ã€‚ç°åœ¨ç”¨ LangGraph å°†å®ƒä»¬ç»„è£…æˆåŠŸèƒ½æ€§çš„çŠ¶æ€æœºã€‚è¿™æ¶‰åŠå®šä¹‰å›¾ç»“æ„ã€æ·»åŠ èŠ‚ç‚¹ä»¥åŠæŒ‡å®šè¿æ¥å®ƒä»¬çš„è¾¹ã€‚

ä¸» `llm_call` èŠ‚ç‚¹è¿è¡Œåï¼Œä»£ç†ä¼šæå‡ºä¸€ä¸ªæˆ–å¤šä¸ªå·¥å…·è°ƒç”¨ã€‚éœ€è¦ä¸€ç§æ–¹æ³•æ¥å†³å®šæ¥ä¸‹æ¥ä¼šå‘ç”Ÿä»€ä¹ˆã€‚ä»£ç†åº”è¯¥åœæ­¢ï¼Œè¿˜æ˜¯åº”è¯¥è¿›å…¥äººå·¥å®¡æŸ¥æ­¥éª¤ï¼Ÿè¿™ç”±æ¡ä»¶è¾¹æ¥å¤„ç†ã€‚å®ƒæ˜¯ä¸€ä¸ªç®€å•çš„å‡½æ•°ï¼Œæ£€æŸ¥çŠ¶æ€ä¸­çš„æœ€åä¸€æ¡æ¶ˆæ¯å¹¶æŒ‡å¯¼å›¾çš„æµç¨‹ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # This function determines the next step after the LLM has made its decision. def should_continue(state: State) -> Literal["interrupt_handler", END]: """Route to the interrupt handler or end the workflow if the 'Done' tool is called.""" # Get the list of messages from the current state. messages = state["messages"] # Get the most recent message, which contains the agent's proposed action. last_message = messages[-1] # Check if the last message contains any tool calls. if last_message.tool_calls: # Loop through each proposed tool call. for tool_call in last_message.tool_calls: # If the agent has decided it's finished, we end the workflow. if tool_call["name"] == "Done": return END # For any other tool, we proceed to the human review step. else: return "interrupt_handler"
```

è¿™ä¸ªå‡½æ•°æ˜¯å“åº”ä»£ç†çš„ä¸»è·¯ç”±å™¨ã€‚å®ƒæ£€æŸ¥ä»£ç†çš„å†³å®šå¹¶å……å½“äº¤é€šè­¦å¯Ÿã€‚å¦‚æœè°ƒç”¨äº† `Done` å·¥å…·ï¼Œé€šè¿‡è¿”å› `END` è¡¨ç¤ºè¿‡ç¨‹å·²å®Œæˆã€‚

å¯¹äºä»»ä½•å…¶ä»–å·¥å…·è°ƒç”¨ï¼Œå®ƒå°†å›¾è·¯ç”±åˆ° `interrupt_handler` èŠ‚ç‚¹è¿›è¡Œäººå·¥å®¡æŸ¥ï¼Œç¡®ä¿åœ¨æœªç»æ‰¹å‡†çš„æƒ…å†µä¸‹ä¸é‡‡å–ä»»ä½•è¡ŒåŠ¨ã€‚

ç°åœ¨å¯ä»¥ç»„è£…å›¾ï¼Œç›´è§‚åœ°çœ‹åˆ°å®ƒçš„æ ·å­ã€‚ç”¨ `StateGraph` å®šä¹‰ç»“æ„ã€‚è¯¥è¿‡ç¨‹æ¶‰åŠä¸¤ä¸ªä¸»è¦é˜¶æ®µï¼š

æ„å»º `response_agent` å­å›¾â€”â€”åŒ…å« `llm_call` -> `interrupt_handler` çš„æ ¸å¿ƒå¾ªç¯ã€‚æ„å»º `overall_workflow`â€”â€”è¿™ä¸ªä¸»å›¾ä» `triage_router` å¼€å§‹ï¼Œå¹¶å°† `response_agent` å­å›¾ä½œä¸ºå…¶èŠ‚ç‚¹ä¹‹ä¸€ã€‚

è¿™ç§æ–¹å¼ä¿æŒæ¶æ„æ¸…æ™°æ˜“æ‡‚ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Import the main graph-building class from LangGraph. from langgraph.graph import StateGraph, START, END # --- Part 1: Build the Response Agent Subgraph --- # Initialize a new state graph with our defined `State` schema. agent_builder = StateGraph(State) # Add the 'llm_call' node to the graph. agent_builder.add_node("llm_call", llm_call) # Add the 'interrupt_handler' node to the graph. agent_builder.add_node("interrupt_handler", interrupt_handler) # Set the entry point of this subgraph to be the 'llm_call' node. agent_builder.add_edge(START, "llm_call") # Add the conditional edge that routes from 'llm_call' to either 'interrupt_handler' or END. agent_builder.add_conditional_edges( "llm_call", should_continue, { "interrupt_handler": "interrupt_handler", END: END, }, ) # After the interrupt handler, the graph always loops back to the LLM to continue the task. agent_builder.add_edge("interrupt_handler", "llm_call") # Compile the subgraph into a runnable object. response_agent = agent_builder.compile() # --- Part 2: Build the Overall Workflow --- # Initialize the main graph, defining its input schema as `StateInput`. overall_workflow = ( StateGraph(State, input=StateInput) # Add the triage router as the first node. .add_node("triage_router", triage_router) # Add the triage interrupt handler node. .add_node("triage_interrupt_handler", triage_interrupt_handler) # Add our entire compiled `response_agent` subgraph as a single node. .add_node("response_agent", response_agent) # Set the entry point for the entire workflow. .add_edge(START, "triage_router") # Define the edges from the triage router to the appropriate next steps. .add_edge("triage_router", "response_agent") .add_edge("triage_router", "triage_interrupt_handler") .add_edge("triage_interrupt_handler", "response_agent") ) # Compile the final, complete graph. email_assistant = overall_workflow.compile()
```

`triage_router` åšåˆæ­¥å†³å®šï¼Œç„¶ååˆ†æ”¯åˆ°ç»“æŸæµç¨‹ã€é€šè¿‡ `triage_interrupt_handler` è¯¢é—®ç”¨æˆ·è¾“å…¥ï¼Œæˆ–è€…å°†æ§åˆ¶æƒäº¤ç»™ `response_agent`ã€‚

`response_agent` è¿›å…¥è‡ªå·±çš„æ€è€ƒï¼ˆ`llm_call`ï¼‰å’Œè¯·æ±‚å®¡æŸ¥ï¼ˆ`interrupt_handler`ï¼‰å¾ªç¯ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­æ›´æ–°è®°å¿†ï¼Œç›´åˆ°ä»»åŠ¡å®Œæˆã€‚

è¿™ç§æœ‰çŠ¶æ€æ¶æ„ä½¿å¾— LangGraph éå¸¸é€‚åˆæ„å»ºå¤æ‚çš„ã€èƒ½å¤Ÿå­¦ä¹ çš„ä»£ç†ã€‚ç°åœ¨å¯ä»¥æ‹¿ç€è¿™ä¸ªç¼–è¯‘å¥½çš„ `email_assistant` å¼€å§‹æµ‹è¯•å®ƒä»åé¦ˆä¸­å­¦ä¹ çš„èƒ½åŠ›ã€‚

### ä½¿ç”¨è®°å¿†æµ‹è¯•ä»£ç†

è®°å¿†åŠŸèƒ½å·²ç»å®ç°åˆ°ç”µå­é‚®ä»¶åŠ©æ‰‹ä¸­ï¼Œæ¥ä¸‹æ¥æµ‹è¯•ç³»ç»Ÿå¦‚ä½•ä»ç”¨æˆ·åé¦ˆä¸­å­¦ä¹ å¹¶éšæ—¶é—´é€‚åº”ã€‚è¿™éƒ¨åˆ†æµ‹è¯•ä¼šæ¢è®¨ä¸åŒç±»å‹çš„ç”¨æˆ·äº¤äº’å¦‚ä½•åˆ›å»ºä¸åŒçš„è®°å¿†æ›´æ–°ï¼Œä»è€Œæé«˜åŠ©æ‰‹æœªæ¥çš„æ€§èƒ½ã€‚

ä¸»è¦è§£å†³ä¸€ä¸‹çš„é—®é¢˜ï¼š

* ç³»ç»Ÿå¦‚ä½•æ•è·å’ŒæŒä¹…åŒ–ç”¨æˆ·åå¥½ï¼Ÿ
* å­˜å‚¨çš„åå¥½ä»¥ä½•ç§æ–¹å¼å½±å“åç»­å†³ç­–è¿‡ç¨‹ï¼Ÿ
* å“ªäº›ç”¨æˆ·äº¤äº’æ¨¡å¼ä¼šè§¦å‘ç‰¹å®šç±»å‹çš„è®°å¿†æ›´æ–°ï¼Ÿ

é¦–å…ˆæ„å»ºä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥æ˜¾ç¤ºè®°å¿†å†…å®¹ï¼Œä»¥ä¾¿åœ¨æ•´ä¸ªæµ‹è¯•è¿‡ç¨‹ä¸­è·Ÿè¸ªå…¶æ¼”å˜ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Import necessary libraries for testing. import uuid from langgraph.checkpoint.memory import MemorySaver from langgraph.types import Command from langgraph.store.memory import InMemoryStore # Define a helper function to display the content of our memory store. def display_memory_content(store, namespace=None): """A utility to print the current state of the memory store.""" # Print a header for clarity. print("\n======= CURRENT MEMORY CONTENT =======") # If a specific namespace is requested, show only that one. if namespace: # Retrieve the memory item for the specified namespace. memory = store.get(namespace, "user_preferences") print(f"\n--- {namespace[1]} ---") if memory: print(memory.value) else: print("No memory found") # If no specific namespace is given, show all of them. else: # Define the list of all possible namespaces we are using. for ns in [ ("email_assistant", "triage_preferences"), ("email_assistant", "response_preferences"), ("email_assistant", "cal_preferences"), ("email_assistant", "background") ]: # Retrieve and print the memory content for each namespace. memory = store.get(ns, "user_preferences") print(f"\n--- {ns[1]} ---") if memory: print(memory.value) else: print("No memory found") print("=======================================\n")
```

è¿™ä¸ªå®ç”¨ç¨‹åºæä¾›äº†ä¸€ä¸ªå®æ—¶çª—å£ï¼Œå¯ä»¥è§‚å¯Ÿä»£ç†ä¸æ–­æ¼”å˜çš„çŸ¥è¯†åº“ï¼Œèƒ½è½»æ¾çœ‹åˆ°æ¯æ¬¡äº¤äº’ååˆ°åº•å­¦åˆ°äº†ä»€ä¹ˆã€‚

å¼€å§‹æ‰§è¡Œä¸åŒçš„æµ‹è¯•ç”¨ä¾‹ã€‚

#### æµ‹è¯•ç”¨ä¾‹ 1ï¼šåŸºçº¿â€”â€”æ¥å—æè®®

ç¬¬ä¸€ä¸ªæµ‹è¯•æ£€æŸ¥å½“ç”¨æˆ·æœªç»ä¿®æ”¹åœ°æ¥å—ä»£ç†æ“ä½œæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚è¿™ä¸ªåŸºçº¿æ¡ˆä¾‹å¸®åŠ©ç†è§£åœ¨æ²¡æœ‰æä¾›åé¦ˆæ—¶ç³»ç»Ÿçš„è¡Œä¸ºã€‚æœŸæœ›ä»£ç†ä½¿ç”¨è®°å¿†æ¥åšå†³å®šï¼Œä½†ä¸ä¼šæ›´æ–°å®ƒã€‚

å…ˆè®¾ç½®ä¸€ä¸ªæ–°çš„æµ‹è¯•è¿è¡Œã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define the input email for our test case. email_input_respond = { "to": "Lance Martin ", "author": "Project Manager ", "subject": "Tax season let's schedule call", "email_thread": "Lance,\n\nIt's tax season again... Are you available sometime next week? ... for about 45 minutes." } # --- Setup for a new test run --- # Initialize a new checkpointer and a fresh, empty memory store. checkpointer = MemorySaver() store = InMemoryStore() # Compile our graph, connecting it to our new checkpointer and store. graph = overall_workflow.compile(checkpointer=checkpointer, store=store) # Create a unique ID and configuration for this conversation. thread_id_1 = uuid.uuid4() thread_config_1 = {"configurable": {"thread_id": thread_id_1}} # Run the graph until its first interrupt. print("Running the graph until the first interrupt...") for chunk in graph.stream({"email_input": email_input_respond}, config=thread_config_1): if '__interrupt__' in chunk: Interrupt_Object = chunk['__interrupt__'][0] print("\nINTERRUPT OBJECT:") print(f"Action Request: {Interrupt_Object.value[0]['action_request']}") # Check the memory state after the first interrupt. display_memory_content(store)
```

å›¾ä¼šä¸€ç›´è¿è¡Œç›´åˆ°ä»£ç†æå‡ºç¬¬ä¸€ä¸ªåŠ¨ä½œå¹¶æš‚åœä¾›å®¡æŸ¥ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 ####### OUTPUT ######### Running the graph until the first interrupt... ğŸ“§ Classification: RESPOND - This email requires a response INTERRUPT OBJECT: Action Request: {'action': 'schedule_meeting', 'args': {'attendees': ['lance@company.com', 'pm@client.com'], 'subject': 'Tax Planning Strategies', 'duration_minutes': 45, ...}} ======= CURRENT MEMORY CONTENT ======= --- triage_preferences --- Emails that are not worth responding to: ... --- response_preferences --- Use professional and concise language. ... --- cal_preferences --- 30 minute meetings are preferred, but 15 minute meetings are also acceptable. --- background --- No memory found =======================================
```

è¾“å‡ºæ˜¾ç¤ºäº†ä¸¤ä»¶å…³é”®çš„äº‹ã€‚é¦–å…ˆï¼Œä»£ç†æ­£ç¡®æå‡ºäº†ä¸€ä¸ª 45 åˆ†é’Ÿçš„ `schedule_meeting` å·¥å…·è°ƒç”¨ï¼Œå°Šé‡äº†å‘ä»¶äººçš„è¯·æ±‚ï¼Œå³ä½¿é»˜è®¤åå¥½æ˜¯ 30 åˆ†é’Ÿã€‚

å…¶æ¬¡ï¼Œ`display_memory_content` å‡½æ•°ç¡®è®¤æ‰€æœ‰è®°å¿†å‘½åç©ºé—´éƒ½å·²ä½¿ç”¨é»˜è®¤å€¼åˆå§‹åŒ–ã€‚å°šæœªå‘ç”Ÿå­¦ä¹ ã€‚

ç°åœ¨æ¥å—ä»£ç†çš„æè®®ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Resume the graph by sending an 'accept' command. print(f"\nSimulating user accepting the {Interrupt_Object.value[0]['action_request']['action']} tool call...") for chunk in graph.stream(Command(resume=[{"type": "accept"}]), config=thread_config_1): # Let the graph run until its next natural pause point. if '__interrupt__' in chunk: Interrupt_Object = chunk['__interrupt__'][0] print("\nINTERRUPT OBJECT:") print(f"Action Request: {Interrupt_Object.value[0]['action_request']}")
```

ä»£ç†æ‰§è¡Œä¼šè®®å·¥å…·å¹¶è¿›å…¥ä¸‹ä¸€ä¸ªé€»è¾‘æ­¥éª¤ï¼šèµ·è‰ä¸€å°ç¡®è®¤é‚®ä»¶ã€‚ç„¶åå†æ¬¡ä¸­æ–­ä¾›å®¡æŸ¥ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 Simulating user accepting the schedule_meeting tool call... INTERRUPT OBJECT: Action Request: {'action': 'write_email', 'args': {'to': 'pm@client.com', 'subject': "Re: Tax season let's schedule call", 'content': 'Dear Project Manager, I have scheduled a meeting...for 45 minutes...'}}
```

ä»£ç†å·²ç»èµ·è‰äº†é€‚å½“çš„ç¡®è®¤é‚®ä»¶ï¼Œç­‰å¾…æœ€ç»ˆæ‰¹å‡†ã€‚ç°åœ¨æ¥å—è¿™ç¬¬äºŒä¸ªæè®®å¹¶æ£€æŸ¥è®°å¿†çš„æœ€ç»ˆçŠ¶æ€ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Resume the graph one last time with another 'accept' command. print(f"\nSimulating user accepting the {Interrupt_Object.value[0]['action_request']['action']} tool call...") for chunk in graph.stream(Command(resume=[{"type": "accept"}]), config=thread_config_1): pass # Let the graph finish. # Check the final state of all memory namespaces. display_memory_content(store)
```

å·¥ä½œæµå®Œæˆã€‚ç”¨æˆ·æ‰¹å‡†äº†ä»£ç†çš„æ‰€æœ‰æ“ä½œã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 ###### OUTPUT ####### Simulating user accepting the write_email tool call... ======= CURRENT MEMORY CONTENT ======= --- triage_preferences --- Emails that are not worth responding to: ... --- response_preferences --- Use professional and concise language. ... --- cal_preferences --- 30 minute meetings are preferred, but 15 minute meetings are also acceptable. --- background --- No memory found =======================================
```

æœ€ç»ˆçš„è®°å¿†æ£€æŸ¥è¯å®äº†å‡è®¾ã€‚å³ä½¿åœ¨ä¸€æ¬¡å®Œæ•´ã€æˆåŠŸçš„è¿è¡Œä¹‹åï¼Œè®°å¿†å†…å®¹ä¹Ÿä¸å…¶åˆå§‹é»˜è®¤çŠ¶æ€ç›¸åŒã€‚è¿™æ˜¯æ­£ç¡®çš„è¡Œä¸ºã€‚ç®€å•çš„æ¥å—ä¸èƒ½æä¾›å¼ºçƒˆçš„å­¦ä¹ ä¿¡å·ï¼Œæ‰€ä»¥ä»£ç†æ˜æ™ºåœ°æ²¡æœ‰æ”¹å˜å…¶é•¿æœŸçŸ¥è¯†ã€‚å®ƒä½¿ç”¨è®°å¿†ï¼Œä½†æ²¡æœ‰æ˜ç¡®åé¦ˆå°±ä¸ä¼šæ”¹å˜å®ƒã€‚

#### æµ‹è¯•ç”¨ä¾‹ 2ï¼šä»ç›´æ¥ç¼–è¾‘ä¸­å­¦ä¹ 

ä¸‹é¢æˆ‘ä»¬æµ‹è¯•ä¸€ä¸ªæœ‰è¶£çš„ä¾‹å­ï¼Œçœ‹çœ‹å½“é€šè¿‡ç›´æ¥ç¼–è¾‘ä»£ç†æè®®æ¥æä¾›æ˜ç¡®åé¦ˆæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚è¿™åˆ›å»ºäº†ä¸€ä¸ªæ¸…æ™°çš„"ä¹‹å‰"å’Œ"ä¹‹å"åœºæ™¯ï¼Œè®°å¿†ç®¡ç†å™¨ LLM å¯ä»¥ä»ä¸­å­¦ä¹ ã€‚

ç”¨ç›¸åŒçš„é‚®ä»¶å¼€å§‹ä¸€æ¬¡æ–°çš„è¿è¡Œã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # --- Setup for a new edit test run --- checkpointer = MemorySaver() store = InMemoryStore() graph = overall_workflow.compile(checkpointer=checkpointer, store=store) thread_id_2 = uuid.uuid4() thread_config_2 = {"configurable": {"thread_id": thread_id_2}} # Run the graph until the first interrupt. print("Running the graph until the first interrupt...") for chunk in graph.stream({"email_input": email_input_respond}, config=thread_config_2): if '__interrupt__' in chunk: Interrupt_Object = chunk['__interrupt__'][0] print("\nINTERRUPT OBJECT:") print(f"Action Request: {Interrupt_Object.value[0]['action_request']}") # Check the initial memory state. display_memory_content(store,("email_assistant", "cal_preferences"))
```

ä»£ç†æš‚åœï¼Œå†æ¬¡æè®®ä¸€ä¸ª 45 åˆ†é’Ÿçš„ä¼šè®®ã€‚ç°åœ¨ä¸æ¥å—ï¼Œè€Œæ˜¯å°†æè®®ç¼–è¾‘æˆçœŸæ­£çš„åå¥½ï¼šä¸€ä¸ª 30 åˆ†é’Ÿçš„ä¼šè®®ï¼Œä¸»é¢˜æ›´ç®€æ´ã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # Define the user's edits to the proposed `schedule_meeting` tool call. edited_schedule_args = { "attendees": ["pm@client.com", "lance@company.com"], "subject": "Tax Planning Discussion", # Changed from "Tax Planning Strategies" "duration_minutes": 30, # Changed from 45 to 30 "preferred_day": "2025-04-22", "start_time": 14 } # Resume the graph by sending an 'edit' command with our new arguments. print("\nSimulating user editing the schedule_meeting tool call...") for chunk in graph.stream(Command(resume=[{"type": "edit", "args": {"args": edited_schedule_args}}]), config=thread_config_2): if '__interrupt__' in chunk: # Capture the next interrupt Interrupt_Object = chunk['__interrupt__'][0] print("\nINTERRUPT OBJECT (Second Interrupt):") print(f"Action Request: {Interrupt_Object.value[0]['action_request']}") # Check the memory AGAIN, after the edit has been processed. print("\nChecking memory after editing schedule_meeting:") display_memory_content(store,("email_assistant", "cal_preferences"))
```

è¿è¡Œè¿™ä¸ªçœ‹çœ‹æ•ˆæœã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 ###### OUTPUT ####### Simulating user editing the schedule_meeting tool call... INTERRUPT OBJECT (Second Interrupt): Action Request: {'action': 'write_email', 'args': {'to': 'pm@client.com', ...}} Checking memory after editing schedule_meeting: ======= CURRENT MEMORY CONTENT ======= --- cal_preferences --- 30 minute meetings are preferred, but 15 minute meetings are also acceptable. The subject of the meeting should be 'Tax Planning Discussion' instead of 'Tax Planning Strategies'. The meeting duration should be 30 minutes instead of 45 minutes. ...
```

è¿™ä¸ªè¾“å‡ºè¯æ˜äº†ç³»ç»Ÿæœ‰æ•ˆã€‚`cal_preferences` è®°å¿†ä¸å†æ˜¯ç®€å•çš„é»˜è®¤å€¼ã€‚è®°å¿†ç®¡ç†å™¨ LLM åˆ†æäº†ä»£ç†æè®®å’Œç¼–è¾‘ä¹‹é—´çš„å·®å¼‚ï¼Œå°†æ›´æ”¹æ¦‚æ‹¬ä¸ºæ›´å¹¿æ³›çš„è§„åˆ™ã€‚

å®ƒå·²ç»å­¦ä¼šäº†å¯¹è¾ƒçŸ­ä¼šè®®å’Œæ›´ç®€æ´ä¸»é¢˜çš„åå¥½ï¼Œè¿™ä¸ªæ–°çŸ¥è¯†ç°åœ¨æˆä¸ºäº†ä»£ç†è®°å¿†çš„æ°¸ä¹…ç»„æˆéƒ¨åˆ†ã€‚

ç°åœ¨é€šè¿‡ç¼–è¾‘é‚®ä»¶è‰ç¨¿æ¥å®Œæˆå·¥ä½œæµã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 # The graph is paused. Let's define our edits for the email draft. edited_email_args = { "to": "pm@client.com", "subject": "Re: Tax Planning Discussion", "content": "Thanks for reaching out. Sounds good. I've scheduled a 30-minute call for us next Tuesday. Looking forward to it!\n\nBest,\nLance" } # Resume the graph with the 'edit' command for the write_email tool. print("\nSimulating user editing the write_email tool call...") for chunk in graph.stream(Command(resume=[{"type": "edit", "args": {"args": edited_email_args}}]), config=thread_config_2): pass # Check the 'response_preferences' memory to see what was learned. print("\nChecking memory after editing write_email:") display_memory_content(store, ("email_assistant", "response_preferences")) print("\n--- Workflow Complete ---")
```

çœ‹çœ‹ç»ˆç«¯ä¸­æ˜¾ç¤ºäº†ä»€ä¹ˆã€‚

ä»£ç è¯­è¨€ï¼šjavascript

å¤åˆ¶

```
 ######## OUTPUT ######### Simulating user editing the write_email tool call... Checking memory after editing write_email: ======= CURRENT MEMORY CONTENT ======= --- response_preferences --- When responding to meeting scheduling requests, the assistant should schedule a meeting for 30 minutes instead of 45 minutes. The assistant should also use the subject line "Re: Tax Planning Discussion" instead of "Re: Tax season let's schedule call". The rest of the user preferences remain the same. --- Workflow Complete ---
```

å†ä¸€æ¬¡å­¦ä¹ æ˜¾è€Œæ˜“è§ã€‚`response_preferences` å·²è¢«æ›´æ–°ã€‚è®°å¿†ç®¡ç†å™¨ LLM æ­£ç¡®è¯†åˆ«äº†è¯­æ°”å’Œç»“æ„ä¸Šçš„å…³é”®å·®å¼‚ï¼Œæå–äº†å…³äºä¸»é¢˜è¡Œå’Œä¼šè®®æ—¶é•¿çš„å¯æ¦‚æ‹¬è§„åˆ™ã€‚

é€šè¿‡åœ¨å•æ¬¡è¿è¡Œä¸­æä¾›ä¸¤æ¬¡ç¼–è¾‘ï¼Œå·²ç»åœ¨ä¸¤ä¸ªä¸åŒé¢†åŸŸä¸ªæ€§åŒ–äº†ä»£ç†è¡Œä¸ºï¼Œå±•ç¤ºäº†è¿™ç§åé¦ˆå¾ªç¯çš„åŠ›é‡ã€‚

### é•¿æœŸè®°å¿†ç³»ç»Ÿçš„å·¥ä½œåŸç†

æˆ‘ä»¬é€šè¿‡æœ¬æ–‡å·²ç»çœ‹åˆ°ä»£ç†ä»åé¦ˆä¸­å­¦ä¹ ï¼Œä½†æ˜¯èƒŒåå‘ç”Ÿäº†ä»€ä¹ˆå‘¢ï¼Ÿè¿™æ˜¯ä¸€ä¸ªç®€å•è€Œå¼ºå¤§çš„å››æ­¥å¾ªç¯ï¼Œå°†æ›´æ­£è½¬åŒ–ä¸ºä»£ç†çš„æ–°è§„åˆ™ã€‚

æ•´ä¸ªè¿‡ç¨‹çš„åˆ†è§£ï¼š

**åé¦ˆæ˜¯è§¦å‘å™¨**ã€‚å­¦ä¹ è¿‡ç¨‹åªåœ¨æä¾›åé¦ˆæ—¶æ‰ä¼šå¼€å§‹ã€‚ç®€å•æ¥å—ä¸€ä¸ªæè®®ä¸ä¼šæ”¹å˜è®°å¿†ã€‚åªæœ‰å½“ç¼–è¾‘ä¸€ä¸ªåŠ¨ä½œæˆ–ç»™å‡ºå¯¹è¯å¼å“åº”æ—¶ï¼Œå­¦ä¹ æ‰ä¼šè¢«è§¦å‘ã€‚

**è°ƒç”¨ä¸“ç”¨çš„è®°å¿†ç®¡ç†å™¨**ã€‚ä¸åªæ˜¯ä¿å­˜åŸå§‹åé¦ˆã€‚è€Œæ˜¯è¿›è¡Œä¸€æ¬¡ç‰¹æ®Šç”¨é€”çš„ LLM è°ƒç”¨ã€‚è¿™ä¸ª"è®°å¿†ç®¡ç†å™¨"ä½¿ç”¨ä¸¥æ ¼çš„ `MEMORY_UPDATE_INSTRUCTIONS` æç¤ºè¯æ¥åˆ†æåé¦ˆã€‚

**å¯¹è®°å¿†è¿›è¡Œç²¾ç¡®æ›´æ–°**ã€‚è®°å¿†ç®¡ç†å™¨çš„ä»»åŠ¡æ˜¯è¿›è¡Œæœ‰é’ˆå¯¹æ€§çš„æ›´æ–°ã€‚å®ƒå°†åé¦ˆä¸ç°æœ‰åå¥½è¿›è¡Œæ¯”è¾ƒï¼Œåœ¨ä¸è¦†ç›–æˆ–åˆ é™¤æ—§è§„åˆ™çš„æƒ…å†µä¸‹é›†æˆæ–°è§„åˆ™ã€‚è¿™ç¡®ä¿ä»£ç†æ°¸è¿œä¸ä¼šå¿˜è®°è¿‡å»çš„æ•™è®­ã€‚

**æ–°çŸ¥è¯†åœ¨ä¸‹æ¬¡è¿è¡Œæ—¶æ³¨å…¥**ã€‚æ›´æ–°åçš„åå¥½å­—ç¬¦ä¸²è¢«ä¿å­˜åˆ° `Store` ä¸­ã€‚ä¸‹æ¬¡ä»£ç†å¼€å§‹æ–°ä»»åŠ¡æ—¶ä¼šè·å–è¿™ä¸ªæ–°å­—ç¬¦ä¸²ï¼Œå°†å­¦åˆ°çš„è¡Œä¸ºæ³¨å…¥å…¶æç¤ºè¯ä¸­ï¼Œæ”¹å˜å…¶æœªæ¥çš„è¡Œä¸ºæ–¹å¼ã€‚

è¿™ä¸ª"è§¦å‘ -> ç®¡ç† -> æ›´æ–° -> æ³¨å…¥"å¾ªç¯ä½¿ä»£ç†èƒ½å¤Ÿä»ä¸€ä¸ªé€šç”¨å·¥å…·æ¼”å˜ä¸ºä¸ªæ€§åŒ–çš„åŠ©æ‰‹ã€‚

ä½œè€…ï¼šFareed Khan

æœ¬æ–‡å‚ä¸Â [è…¾è®¯äº‘è‡ªåª’ä½“åŒæ­¥æ›å…‰è®¡åˆ’](/developer/support-plan)ï¼Œåˆ†äº«è‡ªå¾®ä¿¡å…¬ä¼—å·ã€‚

åŸå§‹å‘è¡¨ï¼š2025-10-20ï¼Œå¦‚æœ‰ä¾µæƒè¯·è”ç³»Â [cloudcommunity@tencent.com](mailto:cloudcommunity@tencent.com) åˆ é™¤

[å­˜å‚¨](/developer/tag/10665)

[prompt](/developer/tag/15406)

[ä»£ç†](/developer/tag/17225)

[å·¥å…·](/developer/tag/17276)

[å‡½æ•°](/developer/tag/17290)

æœ¬æ–‡åˆ†äº«è‡ª DeepHub IMBA å¾®ä¿¡å…¬ä¼—å·ï¼Œå‰å¾€æŸ¥çœ‹

å¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³» [cloudcommunity@tencent.com](mailto:cloudcommunity@tencent.com) åˆ é™¤ã€‚

æœ¬æ–‡å‚ä¸Â [è…¾è®¯äº‘è‡ªåª’ä½“åŒæ­¥æ›å…‰è®¡åˆ’](/developer/support-plan)Â  ï¼Œæ¬¢è¿çƒ­çˆ±å†™ä½œçš„ä½ ä¸€èµ·å‚ä¸ï¼

[å­˜å‚¨](/developer/tag/10665)

[prompt](/developer/tag/15406)

[ä»£ç†](/developer/tag/17225)

[å·¥å…·](/developer/tag/17276)

[å‡½æ•°](/developer/tag/17290)

ç™»å½•åå‚ä¸è¯„è®º

ç™»å½• åå‚ä¸è¯„è®º

* çº¿ç¨‹çº§è®°å¿†ï¼ˆçŸ­æœŸï¼‰

* è·¨çº¿ç¨‹è®°å¿†ï¼ˆé•¿æœŸï¼‰

* LangGraph æ•°æ®æŒä¹…å±‚
  + InMemory Storeï¼ˆç”¨äº notebook å’Œå¿«é€Ÿæµ‹è¯•ï¼‰
  + æœ¬åœ°å¼€å‘å­˜å‚¨ï¼ˆlanggraph devï¼‰
  + ç”Ÿäº§å­˜å‚¨ï¼ˆLangGraph Platform æˆ–è‡ªæ‰˜ç®¡ï¼‰

* InMemory åŠŸèƒ½å®è·µ

* æ„å»ºä»£ç†æ¶æ„
  + å®šä¹‰æ¨¡å¼
  + åˆ›å»ºæç¤ºè¯
  + å®šä¹‰å·¥å…·å’Œå®ç”¨å‡½æ•°

* è®°å¿†åŠŸèƒ½ä¸å›¾èŠ‚ç‚¹

* é€šè¿‡äººæœºåä½œæ•è·åé¦ˆ

* ç»„è£…æˆå·¥ä½œæµ

* ä½¿ç”¨è®°å¿†æµ‹è¯•ä»£ç†
  + æµ‹è¯•ç”¨ä¾‹ 1ï¼šåŸºçº¿â€”â€”æ¥å—æè®®
  + æµ‹è¯•ç”¨ä¾‹ 2ï¼šä»ç›´æ¥ç¼–è¾‘ä¸­å­¦ä¹ 

* é•¿æœŸè®°å¿†ç³»ç»Ÿçš„å·¥ä½œåŸç†

å¯¹è±¡å­˜å‚¨ï¼ˆCloud Object Storageï¼ŒCOSï¼‰æ˜¯ç”±è…¾è®¯äº‘æ¨å‡ºçš„æ— ç›®å½•å±‚æ¬¡ç»“æ„ã€æ— æ•°æ®æ ¼å¼é™åˆ¶ï¼Œå¯å®¹çº³æµ·é‡æ•°æ®ä¸”æ”¯æŒ HTTP/HTTPS åè®®è®¿é—®çš„åˆ†å¸ƒå¼å­˜å‚¨æœåŠ¡ã€‚è…¾è®¯äº‘ COS çš„å­˜å‚¨æ¡¶ç©ºé—´æ— å®¹é‡ä¸Šé™ï¼Œæ— éœ€åˆ†åŒºç®¡ç†ï¼Œé€‚ç”¨äº CDN æ•°æ®åˆ†å‘ã€æ•°æ®ä¸‡è±¡å¤„ç†æˆ–å¤§æ•°æ®è®¡ç®—ä¸åˆ†æçš„æ•°æ®æ¹–ç­‰å¤šç§åœºæ™¯ã€‚

[äº§å“ä»‹ç»](https://cloud.tencent.com/product/cos?from=21341&from_column=21341)[äº§å“æ–‡æ¡£](https://cloud.tencent.com/document/product/436?from=21342&from_column=21342)

* ### ç¤¾åŒº

  + [æŠ€æœ¯æ–‡ç« ](/developer/column)
  + [æŠ€æœ¯é—®ç­”](/developer/ask)
  + [æŠ€æœ¯æ²™é¾™](/developer/salon)
  + [æŠ€æœ¯è§†é¢‘](/developer/video)
  + [å­¦ä¹ ä¸­å¿ƒ](/developer/learning)
  + [æŠ€æœ¯ç™¾ç§‘](/developer/techpedia)
  + [æŠ€æœ¯ä¸“åŒº](/developer/zone/list)
* ### æ´»åŠ¨

  + [è‡ªåª’ä½“åŒæ­¥æ›å…‰è®¡åˆ’](/developer/support-plan)
  + [é‚€è¯·ä½œè€…å…¥é©»](/developer/support-plan-invitation)
  + [è‡ªèä¸Šé¦–é¡µ](/developer/article/1535830)
  + [æŠ€æœ¯ç«èµ›](/developer/competition)
* ### åœˆå±‚

  + [è…¾è®¯äº‘æœ€å…·ä»·å€¼ä¸“å®¶](/tvp)
  + [è…¾è®¯äº‘æ¶æ„å¸ˆæŠ€æœ¯åŒç›Ÿ](/developer/program/tm)
  + [è…¾è®¯äº‘åˆ›ä½œä¹‹æ˜Ÿ](/developer/program/tci)
  + [è…¾è®¯äº‘TDP](/developer/program/tdp)
* ### å…³äº

  + [ç¤¾åŒºè§„èŒƒ](/developer/article/1006434)
  + [å…è´£å£°æ˜](/developer/article/1006435)
  + [è”ç³»æˆ‘ä»¬](mailto:cloudcommunity@tencent.com)
  + [å‹æƒ…é“¾æ¥](/developer/friendlink)
  + [MCPå¹¿åœºå¼€æºç‰ˆæƒå£°æ˜](/developer/article/2537547)

### è…¾è®¯äº‘å¼€å‘è€…

### çƒ­é—¨äº§å“

* [åŸŸåæ³¨å†Œ](/product/domain?from=20064&from_column=20064)
* [äº‘æœåŠ¡å™¨](/product/cvm?from=20064&from_column=20064)
* [åŒºå—é“¾æœåŠ¡](/product/tbaas?from=20064&from_column=20064)
* [æ¶ˆæ¯é˜Ÿåˆ—](/product/message-queue-catalog?from=20064&from_column=20064)
* [ç½‘ç»œåŠ é€Ÿ](/product/ecdn?from=20064&from_column=20064)
* [äº‘æ•°æ®åº“](/product/tencentdb-catalog?from=20064&from_column=20064)
* [åŸŸåè§£æ](/product/dns?from=20064&from_column=20064)
* [äº‘å­˜å‚¨](/product/cos?from=20064&from_column=20064)
* [è§†é¢‘ç›´æ’­](/product/css?from=20064&from_column=20064)

### çƒ­é—¨æ¨è

* [äººè„¸è¯†åˆ«](/product/facerecognition?from=20064&from_column=20064)
* [è…¾è®¯ä¼šè®®](/product/tm?from=20064&from_column=20064)
* [ä¼ä¸šäº‘](/act/pro/enterprise2022?from=20064&from_column=20064)
* [CDNåŠ é€Ÿ](/product/cdn?from=20064&from_column=20064)
* [è§†é¢‘é€šè¯](/product/trtc?from=20064&from_column=20064)
* [å›¾åƒåˆ†æ](/product/imagerecognition?from=20064&from_column=20064)
* [MySQL æ•°æ®åº“](/product/cdb?from=20064&from_column=20064)
* [SSL è¯ä¹¦](/product/ssl?from=20064&from_column=20064)
* [è¯­éŸ³è¯†åˆ«](/product/asr?from=20064&from_column=20064)

### æ›´å¤šæ¨è

* [æ•°æ®å®‰å…¨](/solution/data_protection?from=20064&from_column=20064)
* [è´Ÿè½½å‡è¡¡](/product/clb?from=20064&from_column=20064)
* [çŸ­ä¿¡](/product/sms?from=20064&from_column=20064)
* [æ–‡å­—è¯†åˆ«](/product/ocr?from=20064&from_column=20064)
* [äº‘ç‚¹æ’­](/product/vod?from=20064&from_column=20064)
* [å¤§æ•°æ®](/product/bigdata-class?from=20064&from_column=20064)
* [å°ç¨‹åºå¼€å‘](/solution/la?from=20064&from_column=20064)
* [ç½‘ç«™ç›‘æ§](/product/tcop?from=20064&from_column=20064)
* [æ•°æ®è¿ç§»](/product/cdm?from=20064&from_column=20064)

Copyright Â© 2013 - 2026Tencent Cloud. All Rights Reserved. è…¾è®¯äº‘ ç‰ˆæƒæ‰€æœ‰

[æ·±åœ³å¸‚è…¾è®¯è®¡ç®—æœºç³»ç»Ÿæœ‰é™å…¬å¸](https://qcloudimg.tencent-cloud.cn/raw/986376a919726e0c35e96b311f54184d.jpg)Â ICPå¤‡æ¡ˆ/è®¸å¯è¯å·ï¼š[ç²¤B2-20090059](https://beian.miit.gov.cn/#/Integrated/index)[ç²¤å…¬ç½‘å®‰å¤‡44030502008569å·](https://beian.mps.gov.cn/#/query/webSearch?code=44030502008569)

[è…¾è®¯äº‘è®¡ç®—ï¼ˆåŒ—äº¬ï¼‰æœ‰é™è´£ä»»å…¬å¸](https://qcloudimg.tencent-cloud.cn/raw/a2390663ee4a95ceeead8fdc34d4b207.jpg) äº¬ICPè¯150476å· | Â [äº¬ICPå¤‡11018762å·](https://beian.miit.gov.cn/#/Integrated/index)

[é—®é¢˜å½’æ¡£](/developer/ask/archives.html)[ä¸“æ æ–‡ç« ](/developer/column/archives.html)[å¿«è®¯æ–‡ç« å½’æ¡£](/developer/news/archives.html)[å…³é”®è¯å½’æ¡£](/developer/information/all.html)[å¼€å‘è€…æ‰‹å†Œå½’æ¡£](/developer/devdocs/archives.html)[å¼€å‘è€…æ‰‹å†Œ Section å½’æ¡£](/developer/devdocs/sections_p1.html)

Copyright Â© 2013 - 2026Tencent Cloud.

All Rights Reserved. è…¾è®¯äº‘ ç‰ˆæƒæ‰€æœ‰

ç™»å½• åå‚ä¸è¯„è®º